{"version":3,"sources":["turbopack:///[project]/src/app/api/permissions/digital-assets/route.ts","turbopack:///[project]/node_modules/next/dist/esm/build/templates/app-route.js","turbopack:///[project]/src/lib/cache.ts","turbopack:///[project]/node_modules/lru-cache/src/index.ts","turbopack:///[project]/node_modules/next/dist/src/build/templates/app-route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server'\nimport { withAuth } from '@/lib/middleware'\nimport { checkUserPermissions, SYSTEM_MODULES } from '@/lib/permissions'\nimport { CacheManager } from '@/lib/cache'\n\nexport const GET = withAuth(async (request: NextRequest) => {\n  try {\n    const user = (request as any).user\n\n    // Check cache first\n    const cacheKey = CacheManager.generatePermissionKey(\n      user.department,\n      user.role,\n      'DIGITAL_ASSETS'\n    )\n    \n    const cachedPermissions = CacheManager.getPermissions(cacheKey)\n    if (cachedPermissions) {\n      return NextResponse.json(cachedPermissions)\n    }\n\n    const permissions = await checkUserPermissions(\n      user.department,\n      user.role,\n      SYSTEM_MODULES.DIGITAL_ASSETS\n    )\n\n    return NextResponse.json(permissions)\n  } catch (error) {\n    console.error('Error checking permissions:', error)\n    return NextResponse.json(\n      { error: 'Internal server error' },\n      { status: 500 }\n    )\n  }\n})","import { AppRouteRouteModule } from \"next/dist/esm/server/route-modules/app-route/module.compiled\";\nimport { RouteKind } from \"next/dist/esm/server/route-kind\";\nimport { patchFetch as _patchFetch } from \"next/dist/esm/server/lib/patch-fetch\";\nimport { getRequestMeta } from \"next/dist/esm/server/request-meta\";\nimport { getTracer, SpanKind } from \"next/dist/esm/server/lib/trace/tracer\";\nimport { normalizeAppPath } from \"next/dist/esm/shared/lib/router/utils/app-paths\";\nimport { NodeNextRequest, NodeNextResponse } from \"next/dist/esm/server/base-http/node\";\nimport { NextRequestAdapter, signalFromNodeResponse } from \"next/dist/esm/server/web/spec-extension/adapters/next-request\";\nimport { BaseServerSpan } from \"next/dist/esm/server/lib/trace/constants\";\nimport { getRevalidateReason } from \"next/dist/esm/server/instrumentation/utils\";\nimport { sendResponse } from \"next/dist/esm/server/send-response\";\nimport { fromNodeOutgoingHttpHeaders, toNodeOutgoingHttpHeaders } from \"next/dist/esm/server/web/utils\";\nimport { getCacheControlHeader } from \"next/dist/esm/server/lib/cache-control\";\nimport { INFINITE_CACHE, NEXT_CACHE_TAGS_HEADER } from \"next/dist/esm/lib/constants\";\nimport { NoFallbackError } from \"next/dist/esm/shared/lib/no-fallback-error.external\";\nimport { CachedRouteKind } from \"next/dist/esm/server/response-cache\";\nimport * as userland from \"INNER_APP_ROUTE\";\n// We inject the nextConfigOutput here so that we can use them in the route\n// module.\nconst nextConfigOutput = \"standalone\"\nconst routeModule = new AppRouteRouteModule({\n    definition: {\n        kind: RouteKind.APP_ROUTE,\n        page: \"/api/permissions/digital-assets/route\",\n        pathname: \"/api/permissions/digital-assets\",\n        filename: \"route\",\n        bundlePath: \"\"\n    },\n    distDir: process.env.__NEXT_RELATIVE_DIST_DIR || '',\n    relativeProjectDir: process.env.__NEXT_RELATIVE_PROJECT_DIR || '',\n    resolvedPagePath: \"[project]/src/app/api/permissions/digital-assets/route.ts\",\n    nextConfigOutput,\n    userland\n});\n// Pull out the exports that we need to expose from the module. This should\n// be eliminated when we've moved the other routes to the new format. These\n// are used to hook into the route.\nconst { workAsyncStorage, workUnitAsyncStorage, serverHooks } = routeModule;\nfunction patchFetch() {\n    return _patchFetch({\n        workAsyncStorage,\n        workUnitAsyncStorage\n    });\n}\nexport { routeModule, workAsyncStorage, workUnitAsyncStorage, serverHooks, patchFetch,  };\nexport async function handler(req, res, ctx) {\n    var _nextConfig_experimental;\n    let srcPage = \"/api/permissions/digital-assets/route\";\n    // turbopack doesn't normalize `/index` in the page name\n    // so we need to to process dynamic routes properly\n    // TODO: fix turbopack providing differing value from webpack\n    if (process.env.TURBOPACK) {\n        srcPage = srcPage.replace(/\\/index$/, '') || '/';\n    } else if (srcPage === '/index') {\n        // we always normalize /index specifically\n        srcPage = '/';\n    }\n    const multiZoneDraftMode = process.env.__NEXT_MULTI_ZONE_DRAFT_MODE;\n    const prepareResult = await routeModule.prepare(req, res, {\n        srcPage,\n        multiZoneDraftMode\n    });\n    if (!prepareResult) {\n        res.statusCode = 400;\n        res.end('Bad Request');\n        ctx.waitUntil == null ? void 0 : ctx.waitUntil.call(ctx, Promise.resolve());\n        return null;\n    }\n    const { buildId, params, nextConfig, isDraftMode, prerenderManifest, routerServerContext, isOnDemandRevalidate, revalidateOnlyGenerated, resolvedPathname } = prepareResult;\n    const normalizedSrcPage = normalizeAppPath(srcPage);\n    let isIsr = Boolean(prerenderManifest.dynamicRoutes[normalizedSrcPage] || prerenderManifest.routes[resolvedPathname]);\n    if (isIsr && !isDraftMode) {\n        const isPrerendered = Boolean(prerenderManifest.routes[resolvedPathname]);\n        const prerenderInfo = prerenderManifest.dynamicRoutes[normalizedSrcPage];\n        if (prerenderInfo) {\n            if (prerenderInfo.fallback === false && !isPrerendered) {\n                throw new NoFallbackError();\n            }\n        }\n    }\n    let cacheKey = null;\n    if (isIsr && !routeModule.isDev && !isDraftMode) {\n        cacheKey = resolvedPathname;\n        // ensure /index and / is normalized to one key\n        cacheKey = cacheKey === '/index' ? '/' : cacheKey;\n    }\n    const supportsDynamicResponse = // If we're in development, we always support dynamic HTML\n    routeModule.isDev === true || // If this is not SSG or does not have static paths, then it supports\n    // dynamic HTML.\n    !isIsr;\n    // This is a revalidation request if the request is for a static\n    // page and it is not being resumed from a postponed render and\n    // it is not a dynamic RSC request then it is a revalidation\n    // request.\n    const isRevalidate = isIsr && !supportsDynamicResponse;\n    const method = req.method || 'GET';\n    const tracer = getTracer();\n    const activeSpan = tracer.getActiveScopeSpan();\n    const context = {\n        params,\n        prerenderManifest,\n        renderOpts: {\n            experimental: {\n                cacheComponents: Boolean(nextConfig.experimental.cacheComponents),\n                authInterrupts: Boolean(nextConfig.experimental.authInterrupts)\n            },\n            supportsDynamicResponse,\n            incrementalCache: getRequestMeta(req, 'incrementalCache'),\n            cacheLifeProfiles: (_nextConfig_experimental = nextConfig.experimental) == null ? void 0 : _nextConfig_experimental.cacheLife,\n            isRevalidate,\n            waitUntil: ctx.waitUntil,\n            onClose: (cb)=>{\n                res.on('close', cb);\n            },\n            onAfterTaskError: undefined,\n            onInstrumentationRequestError: (error, _request, errorContext)=>routeModule.onRequestError(req, error, errorContext, routerServerContext)\n        },\n        sharedContext: {\n            buildId\n        }\n    };\n    const nodeNextReq = new NodeNextRequest(req);\n    const nodeNextRes = new NodeNextResponse(res);\n    const nextReq = NextRequestAdapter.fromNodeNextRequest(nodeNextReq, signalFromNodeResponse(res));\n    try {\n        const invokeRouteModule = async (span)=>{\n            return routeModule.handle(nextReq, context).finally(()=>{\n                if (!span) return;\n                span.setAttributes({\n                    'http.status_code': res.statusCode,\n                    'next.rsc': false\n                });\n                const rootSpanAttributes = tracer.getRootSpanAttributes();\n                // We were unable to get attributes, probably OTEL is not enabled\n                if (!rootSpanAttributes) {\n                    return;\n                }\n                if (rootSpanAttributes.get('next.span_type') !== BaseServerSpan.handleRequest) {\n                    console.warn(`Unexpected root span type '${rootSpanAttributes.get('next.span_type')}'. Please report this Next.js issue https://github.com/vercel/next.js`);\n                    return;\n                }\n                const route = rootSpanAttributes.get('next.route');\n                if (route) {\n                    const name = `${method} ${route}`;\n                    span.setAttributes({\n                        'next.route': route,\n                        'http.route': route,\n                        'next.span_name': name\n                    });\n                    span.updateName(name);\n                } else {\n                    span.updateName(`${method} ${req.url}`);\n                }\n            });\n        };\n        const handleResponse = async (currentSpan)=>{\n            var _cacheEntry_value;\n            const responseGenerator = async ({ previousCacheEntry })=>{\n                try {\n                    if (!getRequestMeta(req, 'minimalMode') && isOnDemandRevalidate && revalidateOnlyGenerated && !previousCacheEntry) {\n                        res.statusCode = 404;\n                        // on-demand revalidate always sets this header\n                        res.setHeader('x-nextjs-cache', 'REVALIDATED');\n                        res.end('This page could not be found');\n                        return null;\n                    }\n                    const response = await invokeRouteModule(currentSpan);\n                    req.fetchMetrics = context.renderOpts.fetchMetrics;\n                    let pendingWaitUntil = context.renderOpts.pendingWaitUntil;\n                    // Attempt using provided waitUntil if available\n                    // if it's not we fallback to sendResponse's handling\n                    if (pendingWaitUntil) {\n                        if (ctx.waitUntil) {\n                            ctx.waitUntil(pendingWaitUntil);\n                            pendingWaitUntil = undefined;\n                        }\n                    }\n                    const cacheTags = context.renderOpts.collectedTags;\n                    // If the request is for a static response, we can cache it so long\n                    // as it's not edge.\n                    if (isIsr) {\n                        const blob = await response.blob();\n                        // Copy the headers from the response.\n                        const headers = toNodeOutgoingHttpHeaders(response.headers);\n                        if (cacheTags) {\n                            headers[NEXT_CACHE_TAGS_HEADER] = cacheTags;\n                        }\n                        if (!headers['content-type'] && blob.type) {\n                            headers['content-type'] = blob.type;\n                        }\n                        const revalidate = typeof context.renderOpts.collectedRevalidate === 'undefined' || context.renderOpts.collectedRevalidate >= INFINITE_CACHE ? false : context.renderOpts.collectedRevalidate;\n                        const expire = typeof context.renderOpts.collectedExpire === 'undefined' || context.renderOpts.collectedExpire >= INFINITE_CACHE ? undefined : context.renderOpts.collectedExpire;\n                        // Create the cache entry for the response.\n                        const cacheEntry = {\n                            value: {\n                                kind: CachedRouteKind.APP_ROUTE,\n                                status: response.status,\n                                body: Buffer.from(await blob.arrayBuffer()),\n                                headers\n                            },\n                            cacheControl: {\n                                revalidate,\n                                expire\n                            }\n                        };\n                        return cacheEntry;\n                    } else {\n                        // send response without caching if not ISR\n                        await sendResponse(nodeNextReq, nodeNextRes, response, context.renderOpts.pendingWaitUntil);\n                        return null;\n                    }\n                } catch (err) {\n                    // if this is a background revalidate we need to report\n                    // the request error here as it won't be bubbled\n                    if (previousCacheEntry == null ? void 0 : previousCacheEntry.isStale) {\n                        await routeModule.onRequestError(req, err, {\n                            routerKind: 'App Router',\n                            routePath: srcPage,\n                            routeType: 'route',\n                            revalidateReason: getRevalidateReason({\n                                isRevalidate,\n                                isOnDemandRevalidate\n                            })\n                        }, routerServerContext);\n                    }\n                    throw err;\n                }\n            };\n            const cacheEntry = await routeModule.handleResponse({\n                req,\n                nextConfig,\n                cacheKey,\n                routeKind: RouteKind.APP_ROUTE,\n                isFallback: false,\n                prerenderManifest,\n                isRoutePPREnabled: false,\n                isOnDemandRevalidate,\n                revalidateOnlyGenerated,\n                responseGenerator,\n                waitUntil: ctx.waitUntil\n            });\n            // we don't create a cacheEntry for ISR\n            if (!isIsr) {\n                return null;\n            }\n            if ((cacheEntry == null ? void 0 : (_cacheEntry_value = cacheEntry.value) == null ? void 0 : _cacheEntry_value.kind) !== CachedRouteKind.APP_ROUTE) {\n                var _cacheEntry_value1;\n                throw Object.defineProperty(new Error(`Invariant: app-route received invalid cache entry ${cacheEntry == null ? void 0 : (_cacheEntry_value1 = cacheEntry.value) == null ? void 0 : _cacheEntry_value1.kind}`), \"__NEXT_ERROR_CODE\", {\n                    value: \"E701\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n            if (!getRequestMeta(req, 'minimalMode')) {\n                res.setHeader('x-nextjs-cache', isOnDemandRevalidate ? 'REVALIDATED' : cacheEntry.isMiss ? 'MISS' : cacheEntry.isStale ? 'STALE' : 'HIT');\n            }\n            // Draft mode should never be cached\n            if (isDraftMode) {\n                res.setHeader('Cache-Control', 'private, no-cache, no-store, max-age=0, must-revalidate');\n            }\n            const headers = fromNodeOutgoingHttpHeaders(cacheEntry.value.headers);\n            if (!(getRequestMeta(req, 'minimalMode') && isIsr)) {\n                headers.delete(NEXT_CACHE_TAGS_HEADER);\n            }\n            // If cache control is already set on the response we don't\n            // override it to allow users to customize it via next.config\n            if (cacheEntry.cacheControl && !res.getHeader('Cache-Control') && !headers.get('Cache-Control')) {\n                headers.set('Cache-Control', getCacheControlHeader(cacheEntry.cacheControl));\n            }\n            await sendResponse(nodeNextReq, nodeNextRes, new Response(cacheEntry.value.body, {\n                headers,\n                status: cacheEntry.value.status || 200\n            }));\n            return null;\n        };\n        // TODO: activeSpan code path is for when wrapped by\n        // next-server can be removed when this is no longer used\n        if (activeSpan) {\n            await handleResponse(activeSpan);\n        } else {\n            await tracer.withPropagatedContext(req.headers, ()=>tracer.trace(BaseServerSpan.handleRequest, {\n                    spanName: `${method} ${req.url}`,\n                    kind: SpanKind.SERVER,\n                    attributes: {\n                        'http.method': method,\n                        'http.target': req.url\n                    }\n                }, handleResponse));\n        }\n    } catch (err) {\n        // if we aren't wrapped by base-server handle here\n        if (!activeSpan && !(err instanceof NoFallbackError)) {\n            await routeModule.onRequestError(req, err, {\n                routerKind: 'App Router',\n                routePath: normalizedSrcPage,\n                routeType: 'route',\n                revalidateReason: getRevalidateReason({\n                    isRevalidate,\n                    isOnDemandRevalidate\n                })\n            });\n        }\n        // rethrow so that we can handle serving error page\n        // If this is during static generation, throw the error again.\n        if (isIsr) throw err;\n        // Otherwise, send a 500 response.\n        await sendResponse(nodeNextReq, nodeNextRes, new Response(null, {\n            status: 500\n        }));\n        return null;\n    }\n}\n\n//# sourceMappingURL=app-route.js.map\n","import { LRUCache } from 'lru-cache'\n\n// Cache for permissions - expires after 5 minutes\nconst permissionsCache = new LRUCache<string, any>({\n  max: 1000, // Maximum 1000 entries\n  ttl: 5 * 60 * 1000, // 5 minutes TTL\n})\n\n// Cache for user data - expires after 10 minutes\nconst userCache = new LRUCache<string, any>({\n  max: 500, // Maximum 500 entries\n  ttl: 10 * 60 * 1000, // 10 minutes TTL\n})\n\n// Cache for digital assets - expires after 2 minutes\nconst digitalAssetsCache = new LRUCache<string, any>({\n  max: 100, // Maximum 100 entries\n  ttl: 2 * 60 * 1000, // 2 minutes TTL\n})\n\nexport class CacheManager {\n  // Permission caching\n  static getPermissions(key: string) {\n    return permissionsCache.get(key)\n  }\n\n  static setPermissions(key: string, value: any) {\n    permissionsCache.set(key, value)\n  }\n\n  static clearPermissions(key?: string) {\n    if (key) {\n      permissionsCache.delete(key)\n    } else {\n      permissionsCache.clear()\n    }\n  }\n\n  // User caching\n  static getUser(key: string) {\n    return userCache.get(key)\n  }\n\n  static setUser(key: string, value: any) {\n    userCache.set(key, value)\n  }\n\n  static clearUser(key?: string) {\n    if (key) {\n      userCache.delete(key)\n    } else {\n      userCache.clear()\n    }\n  }\n\n  // Digital assets caching\n  static getDigitalAssets(key: string) {\n    return digitalAssetsCache.get(key)\n  }\n\n  static setDigitalAssets(key: string, value: any) {\n    digitalAssetsCache.set(key, value)\n  }\n\n  static clearDigitalAssets(key?: string) {\n    if (key) {\n      digitalAssetsCache.delete(key)\n    } else {\n      digitalAssetsCache.clear()\n    }\n  }\n\n  // Clear all caches\n  static clearAll() {\n    permissionsCache.clear()\n    userCache.clear()\n    digitalAssetsCache.clear()\n  }\n\n  // Generate cache keys\n  static generatePermissionKey(department: string | null, role: string, module: string) {\n    return `perm:${department || 'null'}:${role}:${module}`\n  }\n\n  static generateUserKey(userId: string) {\n    return `user:${userId}`\n  }\n\n  static generateDigitalAssetsKey(params: {\n    page: number\n    limit: number\n    search?: string\n    aspectRatio?: string\n    department?: string\n  }) {\n    const { page, limit, search = '', aspectRatio = '', department = '' } = params\n    return `digital-assets:${page}:${limit}:${search}:${aspectRatio}:${department}`\n  }\n}","/**\n * @module LRUCache\n */\n\n// module-private names and types\ntype Perf = { now: () => number }\nconst perf: Perf =\n  typeof performance === 'object' &&\n  performance &&\n  typeof performance.now === 'function'\n    ? performance\n    : Date\n\nconst warned = new Set<string>()\n\n// either a function or a class\ntype ForC = ((...a: any[]) => any) | { new (...a: any[]): any }\n\n/* c8 ignore start */\nconst PROCESS = (\n  typeof process === 'object' && !!process ? process : {}\n) as { [k: string]: any }\n/* c8 ignore start */\n\nconst emitWarning = (\n  msg: string,\n  type: string,\n  code: string,\n  fn: ForC\n) => {\n  typeof PROCESS.emitWarning === 'function'\n    ? PROCESS.emitWarning(msg, type, code, fn)\n    : console.error(`[${code}] ${type}: ${msg}`)\n}\n\nlet AC = globalThis.AbortController\nlet AS = globalThis.AbortSignal\n\n/* c8 ignore start */\nif (typeof AC === 'undefined') {\n  //@ts-ignore\n  AS = class AbortSignal {\n    onabort?: (...a: any[]) => any\n    _onabort: ((...a: any[]) => any)[] = []\n    reason?: any\n    aborted: boolean = false\n    addEventListener(_: string, fn: (...a: any[]) => any) {\n      this._onabort.push(fn)\n    }\n  }\n  //@ts-ignore\n  AC = class AbortController {\n    constructor() {\n      warnACPolyfill()\n    }\n    signal = new AS()\n    abort(reason: any) {\n      if (this.signal.aborted) return\n      //@ts-ignore\n      this.signal.reason = reason\n      //@ts-ignore\n      this.signal.aborted = true\n      //@ts-ignore\n      for (const fn of this.signal._onabort) {\n        fn(reason)\n      }\n      this.signal.onabort?.(reason)\n    }\n  }\n  let printACPolyfillWarning =\n    PROCESS.env?.LRU_CACHE_IGNORE_AC_WARNING !== '1'\n  const warnACPolyfill = () => {\n    if (!printACPolyfillWarning) return\n    printACPolyfillWarning = false\n    emitWarning(\n      'AbortController is not defined. If using lru-cache in ' +\n        'node 14, load an AbortController polyfill from the ' +\n        '`node-abort-controller` package. A minimal polyfill is ' +\n        'provided for use by LRUCache.fetch(), but it should not be ' +\n        'relied upon in other contexts (eg, passing it to other APIs that ' +\n        'use AbortController/AbortSignal might have undesirable effects). ' +\n        'You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.',\n      'NO_ABORT_CONTROLLER',\n      'ENOTSUP',\n      warnACPolyfill\n    )\n  }\n}\n/* c8 ignore stop */\n\nconst shouldWarn = (code: string) => !warned.has(code)\n\nconst TYPE = Symbol('type')\nexport type PosInt = number & { [TYPE]: 'Positive Integer' }\nexport type Index = number & { [TYPE]: 'LRUCache Index' }\n\nconst isPosInt = (n: any): n is PosInt =>\n  n && n === Math.floor(n) && n > 0 && isFinite(n)\n\nexport type UintArray = Uint8Array | Uint16Array | Uint32Array\nexport type NumberArray = UintArray | number[]\n\n/* c8 ignore start */\n// This is a little bit ridiculous, tbh.\n// The maximum array length is 2^32-1 or thereabouts on most JS impls.\n// And well before that point, you're caching the entire world, I mean,\n// that's ~32GB of just integers for the next/prev links, plus whatever\n// else to hold that many keys and values.  Just filling the memory with\n// zeroes at init time is brutal when you get that big.\n// But why not be complete?\n// Maybe in the future, these limits will have expanded.\nconst getUintArray = (max: number) =>\n  !isPosInt(max)\n    ? null\n    : max <= Math.pow(2, 8)\n    ? Uint8Array\n    : max <= Math.pow(2, 16)\n    ? Uint16Array\n    : max <= Math.pow(2, 32)\n    ? Uint32Array\n    : max <= Number.MAX_SAFE_INTEGER\n    ? ZeroArray\n    : null\n/* c8 ignore stop */\n\nclass ZeroArray extends Array<number> {\n  constructor(size: number) {\n    super(size)\n    this.fill(0)\n  }\n}\nexport type { ZeroArray }\nexport type { Stack }\n\nexport type StackLike = Stack | Index[]\nclass Stack {\n  heap: NumberArray\n  length: number\n  // private constructor\n  static #constructing: boolean = false\n  static create(max: number): StackLike {\n    const HeapCls = getUintArray(max)\n    if (!HeapCls) return []\n    Stack.#constructing = true\n    const s = new Stack(max, HeapCls)\n    Stack.#constructing = false\n    return s\n  }\n  constructor(\n    max: number,\n    HeapCls: { new (n: number): NumberArray }\n  ) {\n    /* c8 ignore start */\n    if (!Stack.#constructing) {\n      throw new TypeError('instantiate Stack using Stack.create(n)')\n    }\n    /* c8 ignore stop */\n    this.heap = new HeapCls(max)\n    this.length = 0\n  }\n  push(n: Index) {\n    this.heap[this.length++] = n\n  }\n  pop(): Index {\n    return this.heap[--this.length] as Index\n  }\n}\n\n/**\n * Promise representing an in-progress {@link LRUCache#fetch} call\n */\nexport type BackgroundFetch<V> = Promise<V | undefined> & {\n  __returned: BackgroundFetch<V> | undefined\n  __abortController: AbortController\n  __staleWhileFetching: V | undefined\n}\n\nexport type DisposeTask<K, V> = [\n  value: V,\n  key: K,\n  reason: LRUCache.DisposeReason\n]\n\nexport namespace LRUCache {\n  /**\n   * An integer greater than 0, reflecting the calculated size of items\n   */\n  export type Size = number\n\n  /**\n   * Integer greater than 0, representing some number of milliseconds, or the\n   * time at which a TTL started counting from.\n   */\n  export type Milliseconds = number\n\n  /**\n   * An integer greater than 0, reflecting a number of items\n   */\n  export type Count = number\n\n  /**\n   * The reason why an item was removed from the cache, passed\n   * to the {@link Disposer} methods.\n   *\n   * - `evict`: The item was evicted because it is the least recently used,\n   *   and the cache is full.\n   * - `set`: A new value was set, overwriting the old value being disposed.\n   * - `delete`: The item was explicitly deleted, either by calling\n   *   {@link LRUCache#delete}, {@link LRUCache#clear}, or\n   *   {@link LRUCache#set} with an undefined value.\n   * - `expire`: The item was removed due to exceeding its TTL.\n   * - `fetch`: A {@link OptionsBase#fetchMethod} operation returned\n   *   `undefined` or was aborted, causing the item to be deleted.\n   */\n  export type DisposeReason =\n    | 'evict'\n    | 'set'\n    | 'delete'\n    | 'expire'\n    | 'fetch'\n  /**\n   * A method called upon item removal, passed as the\n   * {@link OptionsBase.dispose} and/or\n   * {@link OptionsBase.disposeAfter} options.\n   */\n  export type Disposer<K, V> = (\n    value: V,\n    key: K,\n    reason: DisposeReason\n  ) => void\n\n  /**\n   * A function that returns the effective calculated size\n   * of an entry in the cache.\n   */\n  export type SizeCalculator<K, V> = (value: V, key: K) => Size\n\n  /**\n   * Options provided to the\n   * {@link OptionsBase.fetchMethod} function.\n   */\n  export interface FetcherOptions<K, V, FC = unknown> {\n    signal: AbortSignal\n    options: FetcherFetchOptions<K, V, FC>\n    /**\n     * Object provided in the {@link FetchOptions.context} option to\n     * {@link LRUCache#fetch}\n     */\n    context: FC\n  }\n\n  /**\n   * Occasionally, it may be useful to track the internal behavior of the\n   * cache, particularly for logging, debugging, or for behavior within the\n   * `fetchMethod`. To do this, you can pass a `status` object to the\n   * {@link LRUCache#fetch}, {@link LRUCache#get}, {@link LRUCache#set},\n   * {@link LRUCache#memo}, and {@link LRUCache#has} methods.\n   *\n   * The `status` option should be a plain JavaScript object. The following\n   * fields will be set on it appropriately, depending on the situation.\n   */\n  export interface Status<V> {\n    /**\n     * The status of a set() operation.\n     *\n     * - add: the item was not found in the cache, and was added\n     * - update: the item was in the cache, with the same value provided\n     * - replace: the item was in the cache, and replaced\n     * - miss: the item was not added to the cache for some reason\n     */\n    set?: 'add' | 'update' | 'replace' | 'miss'\n\n    /**\n     * the ttl stored for the item, or undefined if ttls are not used.\n     */\n    ttl?: Milliseconds\n\n    /**\n     * the start time for the item, or undefined if ttls are not used.\n     */\n    start?: Milliseconds\n\n    /**\n     * The timestamp used for TTL calculation\n     */\n    now?: Milliseconds\n\n    /**\n     * the remaining ttl for the item, or undefined if ttls are not used.\n     */\n    remainingTTL?: Milliseconds\n\n    /**\n     * The calculated size for the item, if sizes are used.\n     */\n    entrySize?: Size\n\n    /**\n     * The total calculated size of the cache, if sizes are used.\n     */\n    totalCalculatedSize?: Size\n\n    /**\n     * A flag indicating that the item was not stored, due to exceeding the\n     * {@link OptionsBase.maxEntrySize}\n     */\n    maxEntrySizeExceeded?: true\n\n    /**\n     * The old value, specified in the case of `set:'update'` or\n     * `set:'replace'`\n     */\n    oldValue?: V\n\n    /**\n     * The results of a {@link LRUCache#has} operation\n     *\n     * - hit: the item was found in the cache\n     * - stale: the item was found in the cache, but is stale\n     * - miss: the item was not found in the cache\n     */\n    has?: 'hit' | 'stale' | 'miss'\n\n    /**\n     * The status of a {@link LRUCache#fetch} operation.\n     * Note that this can change as the underlying fetch() moves through\n     * various states.\n     *\n     * - inflight: there is another fetch() for this key which is in process\n     * - get: there is no {@link OptionsBase.fetchMethod}, so\n     *   {@link LRUCache#get} was called.\n     * - miss: the item is not in cache, and will be fetched.\n     * - hit: the item is in the cache, and was resolved immediately.\n     * - stale: the item is in the cache, but stale.\n     * - refresh: the item is in the cache, and not stale, but\n     *   {@link FetchOptions.forceRefresh} was specified.\n     */\n    fetch?: 'get' | 'inflight' | 'miss' | 'hit' | 'stale' | 'refresh'\n\n    /**\n     * The {@link OptionsBase.fetchMethod} was called\n     */\n    fetchDispatched?: true\n\n    /**\n     * The cached value was updated after a successful call to\n     * {@link OptionsBase.fetchMethod}\n     */\n    fetchUpdated?: true\n\n    /**\n     * The reason for a fetch() rejection.  Either the error raised by the\n     * {@link OptionsBase.fetchMethod}, or the reason for an\n     * AbortSignal.\n     */\n    fetchError?: Error\n\n    /**\n     * The fetch received an abort signal\n     */\n    fetchAborted?: true\n\n    /**\n     * The abort signal received was ignored, and the fetch was allowed to\n     * continue.\n     */\n    fetchAbortIgnored?: true\n\n    /**\n     * The fetchMethod promise resolved successfully\n     */\n    fetchResolved?: true\n\n    /**\n     * The fetchMethod promise was rejected\n     */\n    fetchRejected?: true\n\n    /**\n     * The status of a {@link LRUCache#get} operation.\n     *\n     * - fetching: The item is currently being fetched.  If a previous value\n     *   is present and allowed, that will be returned.\n     * - stale: The item is in the cache, and is stale.\n     * - hit: the item is in the cache\n     * - miss: the item is not in the cache\n     */\n    get?: 'stale' | 'hit' | 'miss'\n\n    /**\n     * A fetch or get operation returned a stale value.\n     */\n    returnedStale?: true\n  }\n\n  /**\n   * options which override the options set in the LRUCache constructor\n   * when calling {@link LRUCache#fetch}.\n   *\n   * This is the union of {@link GetOptions} and {@link SetOptions}, plus\n   * {@link OptionsBase.noDeleteOnFetchRejection},\n   * {@link OptionsBase.allowStaleOnFetchRejection},\n   * {@link FetchOptions.forceRefresh}, and\n   * {@link FetcherOptions.context}\n   *\n   * Any of these may be modified in the {@link OptionsBase.fetchMethod}\n   * function, but the {@link GetOptions} fields will of course have no\n   * effect, as the {@link LRUCache#get} call already happened by the time\n   * the fetchMethod is called.\n   */\n  export interface FetcherFetchOptions<K, V, FC = unknown>\n    extends Pick<\n      OptionsBase<K, V, FC>,\n      | 'allowStale'\n      | 'updateAgeOnGet'\n      | 'noDeleteOnStaleGet'\n      | 'sizeCalculation'\n      | 'ttl'\n      | 'noDisposeOnSet'\n      | 'noUpdateTTL'\n      | 'noDeleteOnFetchRejection'\n      | 'allowStaleOnFetchRejection'\n      | 'ignoreFetchAbort'\n      | 'allowStaleOnFetchAbort'\n    > {\n    status?: Status<V>\n    size?: Size\n  }\n\n  /**\n   * Options that may be passed to the {@link LRUCache#fetch} method.\n   */\n  export interface FetchOptions<K, V, FC>\n    extends FetcherFetchOptions<K, V, FC> {\n    /**\n     * Set to true to force a re-load of the existing data, even if it\n     * is not yet stale.\n     */\n    forceRefresh?: boolean\n    /**\n     * Context provided to the {@link OptionsBase.fetchMethod} as\n     * the {@link FetcherOptions.context} param.\n     *\n     * If the FC type is specified as unknown (the default),\n     * undefined or void, then this is optional.  Otherwise, it will\n     * be required.\n     */\n    context?: FC\n    signal?: AbortSignal\n    status?: Status<V>\n  }\n  /**\n   * Options provided to {@link LRUCache#fetch} when the FC type is something\n   * other than `unknown`, `undefined`, or `void`\n   */\n  export interface FetchOptionsWithContext<K, V, FC>\n    extends FetchOptions<K, V, FC> {\n    context: FC\n  }\n  /**\n   * Options provided to {@link LRUCache#fetch} when the FC type is\n   * `undefined` or `void`\n   */\n  export interface FetchOptionsNoContext<K, V>\n    extends FetchOptions<K, V, undefined> {\n    context?: undefined\n  }\n\n  export interface MemoOptions<K, V, FC = unknown>\n    extends Pick<\n      OptionsBase<K, V, FC>,\n      | 'allowStale'\n      | 'updateAgeOnGet'\n      | 'noDeleteOnStaleGet'\n      | 'sizeCalculation'\n      | 'ttl'\n      | 'noDisposeOnSet'\n      | 'noUpdateTTL'\n      | 'noDeleteOnFetchRejection'\n      | 'allowStaleOnFetchRejection'\n      | 'ignoreFetchAbort'\n      | 'allowStaleOnFetchAbort'\n    > {\n    /**\n     * Set to true to force a re-load of the existing data, even if it\n     * is not yet stale.\n     */\n    forceRefresh?: boolean\n    /**\n     * Context provided to the {@link OptionsBase.memoMethod} as\n     * the {@link MemoizerOptions.context} param.\n     *\n     * If the FC type is specified as unknown (the default),\n     * undefined or void, then this is optional.  Otherwise, it will\n     * be required.\n     */\n    context?: FC\n    status?: Status<V>\n  }\n  /**\n   * Options provided to {@link LRUCache#memo} when the FC type is something\n   * other than `unknown`, `undefined`, or `void`\n   */\n  export interface MemoOptionsWithContext<K, V, FC>\n    extends MemoOptions<K, V, FC> {\n    context: FC\n  }\n  /**\n   * Options provided to {@link LRUCache#memo} when the FC type is\n   * `undefined` or `void`\n   */\n  export interface MemoOptionsNoContext<K, V>\n    extends MemoOptions<K, V, undefined> {\n    context?: undefined\n  }\n\n  /**\n   * Options provided to the\n   * {@link OptionsBase.memoMethod} function.\n   */\n  export interface MemoizerOptions<K, V, FC = unknown> {\n    options: MemoizerMemoOptions<K, V, FC>\n    /**\n     * Object provided in the {@link MemoOptions.context} option to\n     * {@link LRUCache#memo}\n     */\n    context: FC\n  }\n\n  /**\n   * options which override the options set in the LRUCache constructor\n   * when calling {@link LRUCache#memo}.\n   *\n   * This is the union of {@link GetOptions} and {@link SetOptions}, plus\n   * {@link MemoOptions.forceRefresh}, and\n   * {@link MemoerOptions.context}\n   *\n   * Any of these may be modified in the {@link OptionsBase.memoMethod}\n   * function, but the {@link GetOptions} fields will of course have no\n   * effect, as the {@link LRUCache#get} call already happened by the time\n   * the memoMethod is called.\n   */\n  export interface MemoizerMemoOptions<K, V, FC = unknown>\n    extends Pick<\n      OptionsBase<K, V, FC>,\n      | 'allowStale'\n      | 'updateAgeOnGet'\n      | 'noDeleteOnStaleGet'\n      | 'sizeCalculation'\n      | 'ttl'\n      | 'noDisposeOnSet'\n      | 'noUpdateTTL'\n    > {\n    status?: Status<V>\n    size?: Size\n    start?: Milliseconds\n  }\n\n  /**\n   * Options that may be passed to the {@link LRUCache#has} method.\n   */\n  export interface HasOptions<K, V, FC>\n    extends Pick<OptionsBase<K, V, FC>, 'updateAgeOnHas'> {\n    status?: Status<V>\n  }\n\n  /**\n   * Options that may be passed to the {@link LRUCache#get} method.\n   */\n  export interface GetOptions<K, V, FC>\n    extends Pick<\n      OptionsBase<K, V, FC>,\n      'allowStale' | 'updateAgeOnGet' | 'noDeleteOnStaleGet'\n    > {\n    status?: Status<V>\n  }\n\n  /**\n   * Options that may be passed to the {@link LRUCache#peek} method.\n   */\n  export interface PeekOptions<K, V, FC>\n    extends Pick<OptionsBase<K, V, FC>, 'allowStale'> {}\n\n  /**\n   * Options that may be passed to the {@link LRUCache#set} method.\n   */\n  export interface SetOptions<K, V, FC>\n    extends Pick<\n      OptionsBase<K, V, FC>,\n      'sizeCalculation' | 'ttl' | 'noDisposeOnSet' | 'noUpdateTTL'\n    > {\n    /**\n     * If size tracking is enabled, then setting an explicit size\n     * in the {@link LRUCache#set} call will prevent calling the\n     * {@link OptionsBase.sizeCalculation} function.\n     */\n    size?: Size\n    /**\n     * If TTL tracking is enabled, then setting an explicit start\n     * time in the {@link LRUCache#set} call will override the\n     * default time from `performance.now()` or `Date.now()`.\n     *\n     * Note that it must be a valid value for whichever time-tracking\n     * method is in use.\n     */\n    start?: Milliseconds\n    status?: Status<V>\n  }\n\n  /**\n   * The type signature for the {@link OptionsBase.fetchMethod} option.\n   */\n  export type Fetcher<K, V, FC = unknown> = (\n    key: K,\n    staleValue: V | undefined,\n    options: FetcherOptions<K, V, FC>\n  ) => Promise<V | undefined | void> | V | undefined | void\n\n  /**\n   * the type signature for the {@link OptionsBase.memoMethod} option.\n   */\n  export type Memoizer<K, V, FC = unknown> = (\n    key: K,\n    staleValue: V | undefined,\n    options: MemoizerOptions<K, V, FC>\n  ) => V\n\n  /**\n   * Options which may be passed to the {@link LRUCache} constructor.\n   *\n   * Most of these may be overridden in the various options that use\n   * them.\n   *\n   * Despite all being technically optional, the constructor requires that\n   * a cache is at minimum limited by one or more of {@link OptionsBase.max},\n   * {@link OptionsBase.ttl}, or {@link OptionsBase.maxSize}.\n   *\n   * If {@link OptionsBase.ttl} is used alone, then it is strongly advised\n   * (and in fact required by the type definitions here) that the cache\n   * also set {@link OptionsBase.ttlAutopurge}, to prevent potentially\n   * unbounded storage.\n   *\n   * All options are also available on the {@link LRUCache} instance, making\n   * it safe to pass an LRUCache instance as the options argumemnt to\n   * make another empty cache of the same type.\n   *\n   * Some options are marked as read-only, because changing them after\n   * instantiation is not safe. Changing any of the other options will of\n   * course only have an effect on subsequent method calls.\n   */\n  export interface OptionsBase<K, V, FC> {\n    /**\n     * The maximum number of items to store in the cache before evicting\n     * old entries. This is read-only on the {@link LRUCache} instance,\n     * and may not be overridden.\n     *\n     * If set, then storage space will be pre-allocated at construction\n     * time, and the cache will perform significantly faster.\n     *\n     * Note that significantly fewer items may be stored, if\n     * {@link OptionsBase.maxSize} and/or {@link OptionsBase.ttl} are also\n     * set.\n     *\n     * **It is strongly recommended to set a `max` to prevent unbounded growth\n     * of the cache.**\n     */\n    max?: Count\n\n    /**\n     * Max time in milliseconds for items to live in cache before they are\n     * considered stale.  Note that stale items are NOT preemptively removed by\n     * default, and MAY live in the cache, contributing to its LRU max, long\n     * after they have expired, unless {@link OptionsBase.ttlAutopurge} is\n     * set.\n     *\n     * If set to `0` (the default value), then that means \"do not track\n     * TTL\", not \"expire immediately\".\n     *\n     * Also, as this cache is optimized for LRU/MRU operations, some of\n     * the staleness/TTL checks will reduce performance, as they will incur\n     * overhead by deleting items.\n     *\n     * This is not primarily a TTL cache, and does not make strong TTL\n     * guarantees. There is no pre-emptive pruning of expired items, but you\n     * _may_ set a TTL on the cache, and it will treat expired items as missing\n     * when they are fetched, and delete them.\n     *\n     * Optional, but must be a non-negative integer in ms if specified.\n     *\n     * This may be overridden by passing an options object to `cache.set()`.\n     *\n     * At least one of `max`, `maxSize`, or `TTL` is required. This must be a\n     * positive integer if set.\n     *\n     * Even if ttl tracking is enabled, **it is strongly recommended to set a\n     * `max` to prevent unbounded growth of the cache.**\n     *\n     * If ttl tracking is enabled, and `max` and `maxSize` are not set,\n     * and `ttlAutopurge` is not set, then a warning will be emitted\n     * cautioning about the potential for unbounded memory consumption.\n     * (The TypeScript definitions will also discourage this.)\n     */\n    ttl?: Milliseconds\n\n    /**\n     * Minimum amount of time in ms in which to check for staleness.\n     * Defaults to 1, which means that the current time is checked\n     * at most once per millisecond.\n     *\n     * Set to 0 to check the current time every time staleness is tested.\n     * (This reduces performance, and is theoretically unnecessary.)\n     *\n     * Setting this to a higher value will improve performance somewhat\n     * while using ttl tracking, albeit at the expense of keeping stale\n     * items around a bit longer than their TTLs would indicate.\n     *\n     * @default 1\n     */\n    ttlResolution?: Milliseconds\n\n    /**\n     * Preemptively remove stale items from the cache.\n     *\n     * Note that this may *significantly* degrade performance, especially if\n     * the cache is storing a large number of items. It is almost always best\n     * to just leave the stale items in the cache, and let them fall out as new\n     * items are added.\n     *\n     * Note that this means that {@link OptionsBase.allowStale} is a bit\n     * pointless, as stale items will be deleted almost as soon as they\n     * expire.\n     *\n     * Use with caution!\n     */\n    ttlAutopurge?: boolean\n\n    /**\n     * When using time-expiring entries with `ttl`, setting this to `true` will\n     * make each item's age reset to 0 whenever it is retrieved from cache with\n     * {@link LRUCache#get}, causing it to not expire. (It can still fall out\n     * of cache based on recency of use, of course.)\n     *\n     * Has no effect if {@link OptionsBase.ttl} is not set.\n     *\n     * This may be overridden by passing an options object to `cache.get()`.\n     */\n    updateAgeOnGet?: boolean\n\n    /**\n     * When using time-expiring entries with `ttl`, setting this to `true` will\n     * make each item's age reset to 0 whenever its presence in the cache is\n     * checked with {@link LRUCache#has}, causing it to not expire. (It can\n     * still fall out of cache based on recency of use, of course.)\n     *\n     * Has no effect if {@link OptionsBase.ttl} is not set.\n     */\n    updateAgeOnHas?: boolean\n\n    /**\n     * Allow {@link LRUCache#get} and {@link LRUCache#fetch} calls to return\n     * stale data, if available.\n     *\n     * By default, if you set `ttl`, stale items will only be deleted from the\n     * cache when you `get(key)`. That is, it's not preemptively pruning items,\n     * unless {@link OptionsBase.ttlAutopurge} is set.\n     *\n     * If you set `allowStale:true`, it'll return the stale value *as well as*\n     * deleting it. If you don't set this, then it'll return `undefined` when\n     * you try to get a stale entry.\n     *\n     * Note that when a stale entry is fetched, _even if it is returned due to\n     * `allowStale` being set_, it is removed from the cache immediately. You\n     * can suppress this behavior by setting\n     * {@link OptionsBase.noDeleteOnStaleGet}, either in the constructor, or in\n     * the options provided to {@link LRUCache#get}.\n     *\n     * This may be overridden by passing an options object to `cache.get()`.\n     * The `cache.has()` method will always return `false` for stale items.\n     *\n     * Only relevant if a ttl is set.\n     */\n    allowStale?: boolean\n\n    /**\n     * Function that is called on items when they are dropped from the\n     * cache, as `dispose(value, key, reason)`.\n     *\n     * This can be handy if you want to close file descriptors or do\n     * other cleanup tasks when items are no longer stored in the cache.\n     *\n     * **NOTE**: It is called _before_ the item has been fully removed\n     * from the cache, so if you want to put it right back in, you need\n     * to wait until the next tick. If you try to add it back in during\n     * the `dispose()` function call, it will break things in subtle and\n     * weird ways.\n     *\n     * Unlike several other options, this may _not_ be overridden by\n     * passing an option to `set()`, for performance reasons.\n     *\n     * The `reason` will be one of the following strings, corresponding\n     * to the reason for the item's deletion:\n     *\n     * - `evict` Item was evicted to make space for a new addition\n     * - `set` Item was overwritten by a new value\n     * - `expire` Item expired its TTL\n     * - `fetch` Item was deleted due to a failed or aborted fetch, or a\n     *   fetchMethod returning `undefined.\n     * - `delete` Item was removed by explicit `cache.delete(key)`,\n     *   `cache.clear()`, or `cache.set(key, undefined)`.\n     */\n    dispose?: Disposer<K, V>\n\n    /**\n     * The same as {@link OptionsBase.dispose}, but called *after* the entry\n     * is completely removed and the cache is once again in a clean state.\n     *\n     * It is safe to add an item right back into the cache at this point.\n     * However, note that it is *very* easy to inadvertently create infinite\n     * recursion this way.\n     */\n    disposeAfter?: Disposer<K, V>\n\n    /**\n     * Set to true to suppress calling the\n     * {@link OptionsBase.dispose} function if the entry key is\n     * still accessible within the cache.\n     *\n     * This may be overridden by passing an options object to\n     * {@link LRUCache#set}.\n     *\n     * Only relevant if `dispose` or `disposeAfter` are set.\n     */\n    noDisposeOnSet?: boolean\n\n    /**\n     * Boolean flag to tell the cache to not update the TTL when setting a new\n     * value for an existing key (ie, when updating a value rather than\n     * inserting a new value).  Note that the TTL value is _always_ set (if\n     * provided) when adding a new entry into the cache.\n     *\n     * Has no effect if a {@link OptionsBase.ttl} is not set.\n     *\n     * May be passed as an option to {@link LRUCache#set}.\n     */\n    noUpdateTTL?: boolean\n\n    /**\n     * Set to a positive integer to track the sizes of items added to the\n     * cache, and automatically evict items in order to stay below this size.\n     * Note that this may result in fewer than `max` items being stored.\n     *\n     * Attempting to add an item to the cache whose calculated size is greater\n     * that this amount will be a no-op. The item will not be cached, and no\n     * other items will be evicted.\n     *\n     * Optional, must be a positive integer if provided.\n     *\n     * Sets `maxEntrySize` to the same value, unless a different value is\n     * provided for `maxEntrySize`.\n     *\n     * At least one of `max`, `maxSize`, or `TTL` is required. This must be a\n     * positive integer if set.\n     *\n     * Even if size tracking is enabled, **it is strongly recommended to set a\n     * `max` to prevent unbounded growth of the cache.**\n     *\n     * Note also that size tracking can negatively impact performance,\n     * though for most cases, only minimally.\n     */\n    maxSize?: Size\n\n    /**\n     * The maximum allowed size for any single item in the cache.\n     *\n     * If a larger item is passed to {@link LRUCache#set} or returned by a\n     * {@link OptionsBase.fetchMethod} or {@link OptionsBase.memoMethod}, then\n     * it will not be stored in the cache.\n     *\n     * Attempting to add an item whose calculated size is greater than\n     * this amount will not cache the item or evict any old items, but\n     * WILL delete an existing value if one is already present.\n     *\n     * Optional, must be a positive integer if provided. Defaults to\n     * the value of `maxSize` if provided.\n     */\n    maxEntrySize?: Size\n\n    /**\n     * A function that returns a number indicating the item's size.\n     *\n     * Requires {@link OptionsBase.maxSize} to be set.\n     *\n     * If not provided, and {@link OptionsBase.maxSize} or\n     * {@link OptionsBase.maxEntrySize} are set, then all\n     * {@link LRUCache#set} calls **must** provide an explicit\n     * {@link SetOptions.size} or sizeCalculation param.\n     */\n    sizeCalculation?: SizeCalculator<K, V>\n\n    /**\n     * Method that provides the implementation for {@link LRUCache#fetch}\n     *\n     * ```ts\n     * fetchMethod(key, staleValue, { signal, options, context })\n     * ```\n     *\n     * If `fetchMethod` is not provided, then `cache.fetch(key)` is equivalent\n     * to `Promise.resolve(cache.get(key))`.\n     *\n     * If at any time, `signal.aborted` is set to `true`, or if the\n     * `signal.onabort` method is called, or if it emits an `'abort'` event\n     * which you can listen to with `addEventListener`, then that means that\n     * the fetch should be abandoned. This may be passed along to async\n     * functions aware of AbortController/AbortSignal behavior.\n     *\n     * The `fetchMethod` should **only** return `undefined` or a Promise\n     * resolving to `undefined` if the AbortController signaled an `abort`\n     * event. In all other cases, it should return or resolve to a value\n     * suitable for adding to the cache.\n     *\n     * The `options` object is a union of the options that may be provided to\n     * `set()` and `get()`. If they are modified, then that will result in\n     * modifying the settings to `cache.set()` when the value is resolved, and\n     * in the case of\n     * {@link OptionsBase.noDeleteOnFetchRejection} and\n     * {@link OptionsBase.allowStaleOnFetchRejection}, the handling of\n     * `fetchMethod` failures.\n     *\n     * For example, a DNS cache may update the TTL based on the value returned\n     * from a remote DNS server by changing `options.ttl` in the `fetchMethod`.\n     */\n    fetchMethod?: Fetcher<K, V, FC>\n\n    /**\n     * Method that provides the implementation for {@link LRUCache#memo}\n     */\n    memoMethod?: Memoizer<K, V, FC>\n\n    /**\n     * Set to true to suppress the deletion of stale data when a\n     * {@link OptionsBase.fetchMethod} returns a rejected promise.\n     */\n    noDeleteOnFetchRejection?: boolean\n\n    /**\n     * Do not delete stale items when they are retrieved with\n     * {@link LRUCache#get}.\n     *\n     * Note that the `get` return value will still be `undefined`\n     * unless {@link OptionsBase.allowStale} is true.\n     *\n     * When using time-expiring entries with `ttl`, by default stale\n     * items will be removed from the cache when the key is accessed\n     * with `cache.get()`.\n     *\n     * Setting this option will cause stale items to remain in the cache, until\n     * they are explicitly deleted with `cache.delete(key)`, or retrieved with\n     * `noDeleteOnStaleGet` set to `false`.\n     *\n     * This may be overridden by passing an options object to `cache.get()`.\n     *\n     * Only relevant if a ttl is used.\n     */\n    noDeleteOnStaleGet?: boolean\n\n    /**\n     * Set to true to allow returning stale data when a\n     * {@link OptionsBase.fetchMethod} throws an error or returns a rejected\n     * promise.\n     *\n     * This differs from using {@link OptionsBase.allowStale} in that stale\n     * data will ONLY be returned in the case that the {@link LRUCache#fetch}\n     * fails, not any other times.\n     *\n     * If a `fetchMethod` fails, and there is no stale value available, the\n     * `fetch()` will resolve to `undefined`. Ie, all `fetchMethod` errors are\n     * suppressed.\n     *\n     * Implies `noDeleteOnFetchRejection`.\n     *\n     * This may be set in calls to `fetch()`, or defaulted on the constructor,\n     * or overridden by modifying the options object in the `fetchMethod`.\n     */\n    allowStaleOnFetchRejection?: boolean\n\n    /**\n     * Set to true to return a stale value from the cache when the\n     * `AbortSignal` passed to the {@link OptionsBase.fetchMethod} dispatches\n     * an `'abort'` event, whether user-triggered, or due to internal cache\n     * behavior.\n     *\n     * Unless {@link OptionsBase.ignoreFetchAbort} is also set, the underlying\n     * {@link OptionsBase.fetchMethod} will still be considered canceled, and\n     * any value it returns will be ignored and not cached.\n     *\n     * Caveat: since fetches are aborted when a new value is explicitly\n     * set in the cache, this can lead to fetch returning a stale value,\n     * since that was the fallback value _at the moment the `fetch()` was\n     * initiated_, even though the new updated value is now present in\n     * the cache.\n     *\n     * For example:\n     *\n     * ```ts\n     * const cache = new LRUCache<string, any>({\n     *   ttl: 100,\n     *   fetchMethod: async (url, oldValue, { signal }) =>  {\n     *     const res = await fetch(url, { signal })\n     *     return await res.json()\n     *   }\n     * })\n     * cache.set('https://example.com/', { some: 'data' })\n     * // 100ms go by...\n     * const result = cache.fetch('https://example.com/')\n     * cache.set('https://example.com/', { other: 'thing' })\n     * console.log(await result) // { some: 'data' }\n     * console.log(cache.get('https://example.com/')) // { other: 'thing' }\n     * ```\n     */\n    allowStaleOnFetchAbort?: boolean\n\n    /**\n     * Set to true to ignore the `abort` event emitted by the `AbortSignal`\n     * object passed to {@link OptionsBase.fetchMethod}, and still cache the\n     * resulting resolution value, as long as it is not `undefined`.\n     *\n     * When used on its own, this means aborted {@link LRUCache#fetch} calls\n     * are not immediately resolved or rejected when they are aborted, and\n     * instead take the full time to await.\n     *\n     * When used with {@link OptionsBase.allowStaleOnFetchAbort}, aborted\n     * {@link LRUCache#fetch} calls will resolve immediately to their stale\n     * cached value or `undefined`, and will continue to process and eventually\n     * update the cache when they resolve, as long as the resulting value is\n     * not `undefined`, thus supporting a \"return stale on timeout while\n     * refreshing\" mechanism by passing `AbortSignal.timeout(n)` as the signal.\n     *\n     * For example:\n     *\n     * ```ts\n     * const c = new LRUCache({\n     *   ttl: 100,\n     *   ignoreFetchAbort: true,\n     *   allowStaleOnFetchAbort: true,\n     *   fetchMethod: async (key, oldValue, { signal }) => {\n     *     // note: do NOT pass the signal to fetch()!\n     *     // let's say this fetch can take a long time.\n     *     const res = await fetch(`https://slow-backend-server/${key}`)\n     *     return await res.json()\n     *   },\n     * })\n     *\n     * // this will return the stale value after 100ms, while still\n     * // updating in the background for next time.\n     * const val = await c.fetch('key', { signal: AbortSignal.timeout(100) })\n     * ```\n     *\n     * **Note**: regardless of this setting, an `abort` event _is still\n     * emitted on the `AbortSignal` object_, so may result in invalid results\n     * when passed to other underlying APIs that use AbortSignals.\n     *\n     * This may be overridden in the {@link OptionsBase.fetchMethod} or the\n     * call to {@link LRUCache#fetch}.\n     */\n    ignoreFetchAbort?: boolean\n  }\n\n  export interface OptionsMaxLimit<K, V, FC>\n    extends OptionsBase<K, V, FC> {\n    max: Count\n  }\n  export interface OptionsTTLLimit<K, V, FC>\n    extends OptionsBase<K, V, FC> {\n    ttl: Milliseconds\n    ttlAutopurge: boolean\n  }\n  export interface OptionsSizeLimit<K, V, FC>\n    extends OptionsBase<K, V, FC> {\n    maxSize: Size\n  }\n\n  /**\n   * The valid safe options for the {@link LRUCache} constructor\n   */\n  export type Options<K, V, FC> =\n    | OptionsMaxLimit<K, V, FC>\n    | OptionsSizeLimit<K, V, FC>\n    | OptionsTTLLimit<K, V, FC>\n\n  /**\n   * Entry objects used by {@link LRUCache#load} and {@link LRUCache#dump},\n   * and returned by {@link LRUCache#info}.\n   */\n  export interface Entry<V> {\n    value: V\n    ttl?: Milliseconds\n    size?: Size\n    start?: Milliseconds\n  }\n}\n\n/**\n * Default export, the thing you're using this module to get.\n *\n * The `K` and `V` types define the key and value types, respectively. The\n * optional `FC` type defines the type of the `context` object passed to\n * `cache.fetch()` and `cache.memo()`.\n *\n * Keys and values **must not** be `null` or `undefined`.\n *\n * All properties from the options object (with the exception of `max`,\n * `maxSize`, `fetchMethod`, `memoMethod`, `dispose` and `disposeAfter`) are\n * added as normal public members. (The listed options are read-only getters.)\n *\n * Changing any of these will alter the defaults for subsequent method calls.\n */\nexport class LRUCache<K extends {}, V extends {}, FC = unknown>\n  implements Map<K, V>\n{\n  // options that cannot be changed without disaster\n  readonly #max: LRUCache.Count\n  readonly #maxSize: LRUCache.Size\n  readonly #dispose?: LRUCache.Disposer<K, V>\n  readonly #disposeAfter?: LRUCache.Disposer<K, V>\n  readonly #fetchMethod?: LRUCache.Fetcher<K, V, FC>\n  readonly #memoMethod?: LRUCache.Memoizer<K, V, FC>\n\n  /**\n   * {@link LRUCache.OptionsBase.ttl}\n   */\n  ttl: LRUCache.Milliseconds\n\n  /**\n   * {@link LRUCache.OptionsBase.ttlResolution}\n   */\n  ttlResolution: LRUCache.Milliseconds\n  /**\n   * {@link LRUCache.OptionsBase.ttlAutopurge}\n   */\n  ttlAutopurge: boolean\n  /**\n   * {@link LRUCache.OptionsBase.updateAgeOnGet}\n   */\n  updateAgeOnGet: boolean\n  /**\n   * {@link LRUCache.OptionsBase.updateAgeOnHas}\n   */\n  updateAgeOnHas: boolean\n  /**\n   * {@link LRUCache.OptionsBase.allowStale}\n   */\n  allowStale: boolean\n\n  /**\n   * {@link LRUCache.OptionsBase.noDisposeOnSet}\n   */\n  noDisposeOnSet: boolean\n  /**\n   * {@link LRUCache.OptionsBase.noUpdateTTL}\n   */\n  noUpdateTTL: boolean\n  /**\n   * {@link LRUCache.OptionsBase.maxEntrySize}\n   */\n  maxEntrySize: LRUCache.Size\n  /**\n   * {@link LRUCache.OptionsBase.sizeCalculation}\n   */\n  sizeCalculation?: LRUCache.SizeCalculator<K, V>\n  /**\n   * {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}\n   */\n  noDeleteOnFetchRejection: boolean\n  /**\n   * {@link LRUCache.OptionsBase.noDeleteOnStaleGet}\n   */\n  noDeleteOnStaleGet: boolean\n  /**\n   * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}\n   */\n  allowStaleOnFetchAbort: boolean\n  /**\n   * {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}\n   */\n  allowStaleOnFetchRejection: boolean\n  /**\n   * {@link LRUCache.OptionsBase.ignoreFetchAbort}\n   */\n  ignoreFetchAbort: boolean\n\n  // computed properties\n  #size: LRUCache.Count\n  #calculatedSize: LRUCache.Size\n  #keyMap: Map<K, Index>\n  #keyList: (K | undefined)[]\n  #valList: (V | BackgroundFetch<V> | undefined)[]\n  #next: NumberArray\n  #prev: NumberArray\n  #head: Index\n  #tail: Index\n  #free: StackLike\n  #disposed?: DisposeTask<K, V>[]\n  #sizes?: ZeroArray\n  #starts?: ZeroArray\n  #ttls?: ZeroArray\n\n  #hasDispose: boolean\n  #hasFetchMethod: boolean\n  #hasDisposeAfter: boolean\n\n  /**\n   * Do not call this method unless you need to inspect the\n   * inner workings of the cache.  If anything returned by this\n   * object is modified in any way, strange breakage may occur.\n   *\n   * These fields are private for a reason!\n   *\n   * @internal\n   */\n  static unsafeExposeInternals<\n    K extends {},\n    V extends {},\n    FC extends unknown = unknown\n  >(c: LRUCache<K, V, FC>) {\n    return {\n      // properties\n      starts: c.#starts,\n      ttls: c.#ttls,\n      sizes: c.#sizes,\n      keyMap: c.#keyMap as Map<K, number>,\n      keyList: c.#keyList,\n      valList: c.#valList,\n      next: c.#next,\n      prev: c.#prev,\n      get head() {\n        return c.#head\n      },\n      get tail() {\n        return c.#tail\n      },\n      free: c.#free,\n      // methods\n      isBackgroundFetch: (p: any) => c.#isBackgroundFetch(p),\n      backgroundFetch: (\n        k: K,\n        index: number | undefined,\n        options: LRUCache.FetchOptions<K, V, FC>,\n        context: any\n      ): BackgroundFetch<V> =>\n        c.#backgroundFetch(\n          k,\n          index as Index | undefined,\n          options,\n          context\n        ),\n      moveToTail: (index: number): void =>\n        c.#moveToTail(index as Index),\n      indexes: (options?: { allowStale: boolean }) =>\n        c.#indexes(options),\n      rindexes: (options?: { allowStale: boolean }) =>\n        c.#rindexes(options),\n      isStale: (index: number | undefined) =>\n        c.#isStale(index as Index),\n    }\n  }\n\n  // Protected read-only members\n\n  /**\n   * {@link LRUCache.OptionsBase.max} (read-only)\n   */\n  get max(): LRUCache.Count {\n    return this.#max\n  }\n  /**\n   * {@link LRUCache.OptionsBase.maxSize} (read-only)\n   */\n  get maxSize(): LRUCache.Count {\n    return this.#maxSize\n  }\n  /**\n   * The total computed size of items in the cache (read-only)\n   */\n  get calculatedSize(): LRUCache.Size {\n    return this.#calculatedSize\n  }\n  /**\n   * The number of items stored in the cache (read-only)\n   */\n  get size(): LRUCache.Count {\n    return this.#size\n  }\n  /**\n   * {@link LRUCache.OptionsBase.fetchMethod} (read-only)\n   */\n  get fetchMethod(): LRUCache.Fetcher<K, V, FC> | undefined {\n    return this.#fetchMethod\n  }\n  get memoMethod(): LRUCache.Memoizer<K, V, FC> | undefined {\n    return this.#memoMethod\n  }\n  /**\n   * {@link LRUCache.OptionsBase.dispose} (read-only)\n   */\n  get dispose() {\n    return this.#dispose\n  }\n  /**\n   * {@link LRUCache.OptionsBase.disposeAfter} (read-only)\n   */\n  get disposeAfter() {\n    return this.#disposeAfter\n  }\n\n  constructor(\n    options: LRUCache.Options<K, V, FC> | LRUCache<K, V, FC>\n  ) {\n    const {\n      max = 0,\n      ttl,\n      ttlResolution = 1,\n      ttlAutopurge,\n      updateAgeOnGet,\n      updateAgeOnHas,\n      allowStale,\n      dispose,\n      disposeAfter,\n      noDisposeOnSet,\n      noUpdateTTL,\n      maxSize = 0,\n      maxEntrySize = 0,\n      sizeCalculation,\n      fetchMethod,\n      memoMethod,\n      noDeleteOnFetchRejection,\n      noDeleteOnStaleGet,\n      allowStaleOnFetchRejection,\n      allowStaleOnFetchAbort,\n      ignoreFetchAbort,\n    } = options\n\n    if (max !== 0 && !isPosInt(max)) {\n      throw new TypeError('max option must be a nonnegative integer')\n    }\n\n    const UintArray = max ? getUintArray(max) : Array\n    if (!UintArray) {\n      throw new Error('invalid max value: ' + max)\n    }\n\n    this.#max = max\n    this.#maxSize = maxSize\n    this.maxEntrySize = maxEntrySize || this.#maxSize\n    this.sizeCalculation = sizeCalculation\n    if (this.sizeCalculation) {\n      if (!this.#maxSize && !this.maxEntrySize) {\n        throw new TypeError(\n          'cannot set sizeCalculation without setting maxSize or maxEntrySize'\n        )\n      }\n      if (typeof this.sizeCalculation !== 'function') {\n        throw new TypeError('sizeCalculation set to non-function')\n      }\n    }\n\n    if (\n      memoMethod !== undefined &&\n      typeof memoMethod !== 'function'\n    ) {\n      throw new TypeError('memoMethod must be a function if defined')\n    }\n    this.#memoMethod = memoMethod\n\n    if (\n      fetchMethod !== undefined &&\n      typeof fetchMethod !== 'function'\n    ) {\n      throw new TypeError(\n        'fetchMethod must be a function if specified'\n      )\n    }\n    this.#fetchMethod = fetchMethod\n    this.#hasFetchMethod = !!fetchMethod\n\n    this.#keyMap = new Map()\n    this.#keyList = new Array(max).fill(undefined)\n    this.#valList = new Array(max).fill(undefined)\n    this.#next = new UintArray(max)\n    this.#prev = new UintArray(max)\n    this.#head = 0 as Index\n    this.#tail = 0 as Index\n    this.#free = Stack.create(max)\n    this.#size = 0\n    this.#calculatedSize = 0\n\n    if (typeof dispose === 'function') {\n      this.#dispose = dispose\n    }\n    if (typeof disposeAfter === 'function') {\n      this.#disposeAfter = disposeAfter\n      this.#disposed = []\n    } else {\n      this.#disposeAfter = undefined\n      this.#disposed = undefined\n    }\n    this.#hasDispose = !!this.#dispose\n    this.#hasDisposeAfter = !!this.#disposeAfter\n\n    this.noDisposeOnSet = !!noDisposeOnSet\n    this.noUpdateTTL = !!noUpdateTTL\n    this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection\n    this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection\n    this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort\n    this.ignoreFetchAbort = !!ignoreFetchAbort\n\n    // NB: maxEntrySize is set to maxSize if it's set\n    if (this.maxEntrySize !== 0) {\n      if (this.#maxSize !== 0) {\n        if (!isPosInt(this.#maxSize)) {\n          throw new TypeError(\n            'maxSize must be a positive integer if specified'\n          )\n        }\n      }\n      if (!isPosInt(this.maxEntrySize)) {\n        throw new TypeError(\n          'maxEntrySize must be a positive integer if specified'\n        )\n      }\n      this.#initializeSizeTracking()\n    }\n\n    this.allowStale = !!allowStale\n    this.noDeleteOnStaleGet = !!noDeleteOnStaleGet\n    this.updateAgeOnGet = !!updateAgeOnGet\n    this.updateAgeOnHas = !!updateAgeOnHas\n    this.ttlResolution =\n      isPosInt(ttlResolution) || ttlResolution === 0\n        ? ttlResolution\n        : 1\n    this.ttlAutopurge = !!ttlAutopurge\n    this.ttl = ttl || 0\n    if (this.ttl) {\n      if (!isPosInt(this.ttl)) {\n        throw new TypeError(\n          'ttl must be a positive integer if specified'\n        )\n      }\n      this.#initializeTTLTracking()\n    }\n\n    // do not allow completely unbounded caches\n    if (this.#max === 0 && this.ttl === 0 && this.#maxSize === 0) {\n      throw new TypeError(\n        'At least one of max, maxSize, or ttl is required'\n      )\n    }\n    if (!this.ttlAutopurge && !this.#max && !this.#maxSize) {\n      const code = 'LRU_CACHE_UNBOUNDED'\n      if (shouldWarn(code)) {\n        warned.add(code)\n        const msg =\n          'TTL caching without ttlAutopurge, max, or maxSize can ' +\n          'result in unbounded memory consumption.'\n        emitWarning(msg, 'UnboundedCacheWarning', code, LRUCache)\n      }\n    }\n  }\n\n  /**\n   * Return the number of ms left in the item's TTL. If item is not in cache,\n   * returns `0`. Returns `Infinity` if item is in cache without a defined TTL.\n   */\n  getRemainingTTL(key: K) {\n    return this.#keyMap.has(key) ? Infinity : 0\n  }\n\n  #initializeTTLTracking() {\n    const ttls = new ZeroArray(this.#max)\n    const starts = new ZeroArray(this.#max)\n    this.#ttls = ttls\n    this.#starts = starts\n\n    this.#setItemTTL = (index, ttl, start = perf.now()) => {\n      starts[index] = ttl !== 0 ? start : 0\n      ttls[index] = ttl\n      if (ttl !== 0 && this.ttlAutopurge) {\n        const t = setTimeout(() => {\n          if (this.#isStale(index)) {\n            this.#delete(this.#keyList[index] as K, 'expire')\n          }\n        }, ttl + 1)\n        // unref() not supported on all platforms\n        /* c8 ignore start */\n        if (t.unref) {\n          t.unref()\n        }\n        /* c8 ignore stop */\n      }\n    }\n\n    this.#updateItemAge = index => {\n      starts[index] = ttls[index] !== 0 ? perf.now() : 0\n    }\n\n    this.#statusTTL = (status, index) => {\n      if (ttls[index]) {\n        const ttl = ttls[index]\n        const start = starts[index]\n        /* c8 ignore next */\n        if (!ttl || !start) return\n        status.ttl = ttl\n        status.start = start\n        status.now = cachedNow || getNow()\n        const age = status.now - start\n        status.remainingTTL = ttl - age\n      }\n    }\n\n    // debounce calls to perf.now() to 1s so we're not hitting\n    // that costly call repeatedly.\n    let cachedNow = 0\n    const getNow = () => {\n      const n = perf.now()\n      if (this.ttlResolution > 0) {\n        cachedNow = n\n        const t = setTimeout(\n          () => (cachedNow = 0),\n          this.ttlResolution\n        )\n        // not available on all platforms\n        /* c8 ignore start */\n        if (t.unref) {\n          t.unref()\n        }\n        /* c8 ignore stop */\n      }\n      return n\n    }\n\n    this.getRemainingTTL = key => {\n      const index = this.#keyMap.get(key)\n      if (index === undefined) {\n        return 0\n      }\n      const ttl = ttls[index]\n      const start = starts[index]\n      if (!ttl || !start) {\n        return Infinity\n      }\n      const age = (cachedNow || getNow()) - start\n      return ttl - age\n    }\n\n    this.#isStale = index => {\n      const s = starts[index]\n      const t = ttls[index]\n      return !!t && !!s && (cachedNow || getNow()) - s > t\n    }\n  }\n\n  // conditionally set private methods related to TTL\n  #updateItemAge: (index: Index) => void = () => {}\n  #statusTTL: (status: LRUCache.Status<V>, index: Index) => void =\n    () => {}\n  #setItemTTL: (\n    index: Index,\n    ttl: LRUCache.Milliseconds,\n    start?: LRUCache.Milliseconds\n    // ignore because we never call this if we're not already in TTL mode\n    /* c8 ignore start */\n  ) => void = () => {}\n  /* c8 ignore stop */\n\n  #isStale: (index: Index) => boolean = () => false\n\n  #initializeSizeTracking() {\n    const sizes = new ZeroArray(this.#max)\n    this.#calculatedSize = 0\n    this.#sizes = sizes\n    this.#removeItemSize = index => {\n      this.#calculatedSize -= sizes[index] as number\n      sizes[index] = 0\n    }\n    this.#requireSize = (k, v, size, sizeCalculation) => {\n      // provisionally accept background fetches.\n      // actual value size will be checked when they return.\n      if (this.#isBackgroundFetch(v)) {\n        return 0\n      }\n      if (!isPosInt(size)) {\n        if (sizeCalculation) {\n          if (typeof sizeCalculation !== 'function') {\n            throw new TypeError('sizeCalculation must be a function')\n          }\n          size = sizeCalculation(v, k)\n          if (!isPosInt(size)) {\n            throw new TypeError(\n              'sizeCalculation return invalid (expect positive integer)'\n            )\n          }\n        } else {\n          throw new TypeError(\n            'invalid size value (must be positive integer). ' +\n              'When maxSize or maxEntrySize is used, sizeCalculation ' +\n              'or size must be set.'\n          )\n        }\n      }\n      return size\n    }\n    this.#addItemSize = (\n      index: Index,\n      size: LRUCache.Size,\n      status?: LRUCache.Status<V>\n    ) => {\n      sizes[index] = size\n      if (this.#maxSize) {\n        const maxSize = this.#maxSize - (sizes[index] as number)\n        while (this.#calculatedSize > maxSize) {\n          this.#evict(true)\n        }\n      }\n      this.#calculatedSize += sizes[index] as number\n      if (status) {\n        status.entrySize = size\n        status.totalCalculatedSize = this.#calculatedSize\n      }\n    }\n  }\n\n  #removeItemSize: (index: Index) => void = _i => {}\n  #addItemSize: (\n    index: Index,\n    size: LRUCache.Size,\n    status?: LRUCache.Status<V>\n  ) => void = (_i, _s, _st) => {}\n  #requireSize: (\n    k: K,\n    v: V | BackgroundFetch<V>,\n    size?: LRUCache.Size,\n    sizeCalculation?: LRUCache.SizeCalculator<K, V>\n  ) => LRUCache.Size = (\n    _k: K,\n    _v: V | BackgroundFetch<V>,\n    size?: LRUCache.Size,\n    sizeCalculation?: LRUCache.SizeCalculator<K, V>\n  ) => {\n    if (size || sizeCalculation) {\n      throw new TypeError(\n        'cannot set size without setting maxSize or maxEntrySize on cache'\n      )\n    }\n    return 0\n  };\n\n  *#indexes({ allowStale = this.allowStale } = {}) {\n    if (this.#size) {\n      for (let i = this.#tail; true; ) {\n        if (!this.#isValidIndex(i)) {\n          break\n        }\n        if (allowStale || !this.#isStale(i)) {\n          yield i\n        }\n        if (i === this.#head) {\n          break\n        } else {\n          i = this.#prev[i] as Index\n        }\n      }\n    }\n  }\n\n  *#rindexes({ allowStale = this.allowStale } = {}) {\n    if (this.#size) {\n      for (let i = this.#head; true; ) {\n        if (!this.#isValidIndex(i)) {\n          break\n        }\n        if (allowStale || !this.#isStale(i)) {\n          yield i\n        }\n        if (i === this.#tail) {\n          break\n        } else {\n          i = this.#next[i] as Index\n        }\n      }\n    }\n  }\n\n  #isValidIndex(index: Index) {\n    return (\n      index !== undefined &&\n      this.#keyMap.get(this.#keyList[index] as K) === index\n    )\n  }\n\n  /**\n   * Return a generator yielding `[key, value]` pairs,\n   * in order from most recently used to least recently used.\n   */\n  *entries() {\n    for (const i of this.#indexes()) {\n      if (\n        this.#valList[i] !== undefined &&\n        this.#keyList[i] !== undefined &&\n        !this.#isBackgroundFetch(this.#valList[i])\n      ) {\n        yield [this.#keyList[i], this.#valList[i]] as [K, V]\n      }\n    }\n  }\n\n  /**\n   * Inverse order version of {@link LRUCache.entries}\n   *\n   * Return a generator yielding `[key, value]` pairs,\n   * in order from least recently used to most recently used.\n   */\n  *rentries() {\n    for (const i of this.#rindexes()) {\n      if (\n        this.#valList[i] !== undefined &&\n        this.#keyList[i] !== undefined &&\n        !this.#isBackgroundFetch(this.#valList[i])\n      ) {\n        yield [this.#keyList[i], this.#valList[i]]\n      }\n    }\n  }\n\n  /**\n   * Return a generator yielding the keys in the cache,\n   * in order from most recently used to least recently used.\n   */\n  *keys() {\n    for (const i of this.#indexes()) {\n      const k = this.#keyList[i]\n      if (\n        k !== undefined &&\n        !this.#isBackgroundFetch(this.#valList[i])\n      ) {\n        yield k\n      }\n    }\n  }\n\n  /**\n   * Inverse order version of {@link LRUCache.keys}\n   *\n   * Return a generator yielding the keys in the cache,\n   * in order from least recently used to most recently used.\n   */\n  *rkeys() {\n    for (const i of this.#rindexes()) {\n      const k = this.#keyList[i]\n      if (\n        k !== undefined &&\n        !this.#isBackgroundFetch(this.#valList[i])\n      ) {\n        yield k\n      }\n    }\n  }\n\n  /**\n   * Return a generator yielding the values in the cache,\n   * in order from most recently used to least recently used.\n   */\n  *values() {\n    for (const i of this.#indexes()) {\n      const v = this.#valList[i]\n      if (\n        v !== undefined &&\n        !this.#isBackgroundFetch(this.#valList[i])\n      ) {\n        yield this.#valList[i] as V\n      }\n    }\n  }\n\n  /**\n   * Inverse order version of {@link LRUCache.values}\n   *\n   * Return a generator yielding the values in the cache,\n   * in order from least recently used to most recently used.\n   */\n  *rvalues() {\n    for (const i of this.#rindexes()) {\n      const v = this.#valList[i]\n      if (\n        v !== undefined &&\n        !this.#isBackgroundFetch(this.#valList[i])\n      ) {\n        yield this.#valList[i]\n      }\n    }\n  }\n\n  /**\n   * Iterating over the cache itself yields the same results as\n   * {@link LRUCache.entries}\n   */\n  [Symbol.iterator]() {\n    return this.entries()\n  }\n\n  /**\n   * A String value that is used in the creation of the default string\n   * description of an object. Called by the built-in method\n   * `Object.prototype.toString`.\n   */\n  [Symbol.toStringTag] = 'LRUCache'\n\n  /**\n   * Find a value for which the supplied fn method returns a truthy value,\n   * similar to `Array.find()`. fn is called as `fn(value, key, cache)`.\n   */\n  find(\n    fn: (v: V, k: K, self: LRUCache<K, V, FC>) => boolean,\n    getOptions: LRUCache.GetOptions<K, V, FC> = {}\n  ) {\n    for (const i of this.#indexes()) {\n      const v = this.#valList[i]\n      const value = this.#isBackgroundFetch(v)\n        ? v.__staleWhileFetching\n        : v\n      if (value === undefined) continue\n      if (fn(value, this.#keyList[i] as K, this)) {\n        return this.get(this.#keyList[i] as K, getOptions)\n      }\n    }\n  }\n\n  /**\n   * Call the supplied function on each item in the cache, in order from most\n   * recently used to least recently used.\n   *\n   * `fn` is called as `fn(value, key, cache)`.\n   *\n   * If `thisp` is provided, function will be called in the `this`-context of\n   * the provided object, or the cache if no `thisp` object is provided.\n   *\n   * Does not update age or recenty of use, or iterate over stale values.\n   */\n  forEach(\n    fn: (v: V, k: K, self: LRUCache<K, V, FC>) => any,\n    thisp: any = this\n  ) {\n    for (const i of this.#indexes()) {\n      const v = this.#valList[i]\n      const value = this.#isBackgroundFetch(v)\n        ? v.__staleWhileFetching\n        : v\n      if (value === undefined) continue\n      fn.call(thisp, value, this.#keyList[i] as K, this)\n    }\n  }\n\n  /**\n   * The same as {@link LRUCache.forEach} but items are iterated over in\n   * reverse order.  (ie, less recently used items are iterated over first.)\n   */\n  rforEach(\n    fn: (v: V, k: K, self: LRUCache<K, V, FC>) => any,\n    thisp: any = this\n  ) {\n    for (const i of this.#rindexes()) {\n      const v = this.#valList[i]\n      const value = this.#isBackgroundFetch(v)\n        ? v.__staleWhileFetching\n        : v\n      if (value === undefined) continue\n      fn.call(thisp, value, this.#keyList[i] as K, this)\n    }\n  }\n\n  /**\n   * Delete any stale entries. Returns true if anything was removed,\n   * false otherwise.\n   */\n  purgeStale() {\n    let deleted = false\n    for (const i of this.#rindexes({ allowStale: true })) {\n      if (this.#isStale(i)) {\n        this.#delete(this.#keyList[i] as K, 'expire')\n        deleted = true\n      }\n    }\n    return deleted\n  }\n\n  /**\n   * Get the extended info about a given entry, to get its value, size, and\n   * TTL info simultaneously. Returns `undefined` if the key is not present.\n   *\n   * Unlike {@link LRUCache#dump}, which is designed to be portable and survive\n   * serialization, the `start` value is always the current timestamp, and the\n   * `ttl` is a calculated remaining time to live (negative if expired).\n   *\n   * Always returns stale values, if their info is found in the cache, so be\n   * sure to check for expirations (ie, a negative {@link LRUCache.Entry#ttl})\n   * if relevant.\n   */\n  info(key: K): LRUCache.Entry<V> | undefined {\n    const i = this.#keyMap.get(key)\n    if (i === undefined) return undefined\n    const v = this.#valList[i]\n    const value: V | undefined = this.#isBackgroundFetch(v)\n      ? v.__staleWhileFetching\n      : v\n    if (value === undefined) return undefined\n    const entry: LRUCache.Entry<V> = { value }\n    if (this.#ttls && this.#starts) {\n      const ttl = this.#ttls[i]\n      const start = this.#starts[i]\n      if (ttl && start) {\n        const remain = ttl - (perf.now() - start)\n        entry.ttl = remain\n        entry.start = Date.now()\n      }\n    }\n    if (this.#sizes) {\n      entry.size = this.#sizes[i]\n    }\n    return entry\n  }\n\n  /**\n   * Return an array of [key, {@link LRUCache.Entry}] tuples which can be\n   * passed to {@link LRLUCache#load}.\n   *\n   * The `start` fields are calculated relative to a portable `Date.now()`\n   * timestamp, even if `performance.now()` is available.\n   *\n   * Stale entries are always included in the `dump`, even if\n   * {@link LRUCache.OptionsBase.allowStale} is false.\n   *\n   * Note: this returns an actual array, not a generator, so it can be more\n   * easily passed around.\n   */\n  dump() {\n    const arr: [K, LRUCache.Entry<V>][] = []\n    for (const i of this.#indexes({ allowStale: true })) {\n      const key = this.#keyList[i]\n      const v = this.#valList[i]\n      const value: V | undefined = this.#isBackgroundFetch(v)\n        ? v.__staleWhileFetching\n        : v\n      if (value === undefined || key === undefined) continue\n      const entry: LRUCache.Entry<V> = { value }\n      if (this.#ttls && this.#starts) {\n        entry.ttl = this.#ttls[i]\n        // always dump the start relative to a portable timestamp\n        // it's ok for this to be a bit slow, it's a rare operation.\n        const age = perf.now() - (this.#starts[i] as number)\n        entry.start = Math.floor(Date.now() - age)\n      }\n      if (this.#sizes) {\n        entry.size = this.#sizes[i]\n      }\n      arr.unshift([key, entry])\n    }\n    return arr\n  }\n\n  /**\n   * Reset the cache and load in the items in entries in the order listed.\n   *\n   * The shape of the resulting cache may be different if the same options are\n   * not used in both caches.\n   *\n   * The `start` fields are assumed to be calculated relative to a portable\n   * `Date.now()` timestamp, even if `performance.now()` is available.\n   */\n  load(arr: [K, LRUCache.Entry<V>][]) {\n    this.clear()\n    for (const [key, entry] of arr) {\n      if (entry.start) {\n        // entry.start is a portable timestamp, but we may be using\n        // node's performance.now(), so calculate the offset, so that\n        // we get the intended remaining TTL, no matter how long it's\n        // been on ice.\n        //\n        // it's ok for this to be a bit slow, it's a rare operation.\n        const age = Date.now() - entry.start\n        entry.start = perf.now() - age\n      }\n      this.set(key, entry.value, entry)\n    }\n  }\n\n  /**\n   * Add a value to the cache.\n   *\n   * Note: if `undefined` is specified as a value, this is an alias for\n   * {@link LRUCache#delete}\n   *\n   * Fields on the {@link LRUCache.SetOptions} options param will override\n   * their corresponding values in the constructor options for the scope\n   * of this single `set()` operation.\n   *\n   * If `start` is provided, then that will set the effective start\n   * time for the TTL calculation. Note that this must be a previous\n   * value of `performance.now()` if supported, or a previous value of\n   * `Date.now()` if not.\n   *\n   * Options object may also include `size`, which will prevent\n   * calling the `sizeCalculation` function and just use the specified\n   * number if it is a positive integer, and `noDisposeOnSet` which\n   * will prevent calling a `dispose` function in the case of\n   * overwrites.\n   *\n   * If the `size` (or return value of `sizeCalculation`) for a given\n   * entry is greater than `maxEntrySize`, then the item will not be\n   * added to the cache.\n   *\n   * Will update the recency of the entry.\n   *\n   * If the value is `undefined`, then this is an alias for\n   * `cache.delete(key)`. `undefined` is never stored in the cache.\n   */\n  set(\n    k: K,\n    v: V | BackgroundFetch<V> | undefined,\n    setOptions: LRUCache.SetOptions<K, V, FC> = {}\n  ) {\n    if (v === undefined) {\n      this.delete(k)\n      return this\n    }\n    const {\n      ttl = this.ttl,\n      start,\n      noDisposeOnSet = this.noDisposeOnSet,\n      sizeCalculation = this.sizeCalculation,\n      status,\n    } = setOptions\n    let { noUpdateTTL = this.noUpdateTTL } = setOptions\n\n    const size = this.#requireSize(\n      k,\n      v,\n      setOptions.size || 0,\n      sizeCalculation\n    )\n    // if the item doesn't fit, don't do anything\n    // NB: maxEntrySize set to maxSize by default\n    if (this.maxEntrySize && size > this.maxEntrySize) {\n      if (status) {\n        status.set = 'miss'\n        status.maxEntrySizeExceeded = true\n      }\n      // have to delete, in case something is there already.\n      this.#delete(k, 'set')\n      return this\n    }\n    let index = this.#size === 0 ? undefined : this.#keyMap.get(k)\n    if (index === undefined) {\n      // addition\n      index = (\n        this.#size === 0\n          ? this.#tail\n          : this.#free.length !== 0\n          ? this.#free.pop()\n          : this.#size === this.#max\n          ? this.#evict(false)\n          : this.#size\n      ) as Index\n      this.#keyList[index] = k\n      this.#valList[index] = v\n      this.#keyMap.set(k, index)\n      this.#next[this.#tail] = index\n      this.#prev[index] = this.#tail\n      this.#tail = index\n      this.#size++\n      this.#addItemSize(index, size, status)\n      if (status) status.set = 'add'\n      noUpdateTTL = false\n    } else {\n      // update\n      this.#moveToTail(index)\n      const oldVal = this.#valList[index] as V | BackgroundFetch<V>\n      if (v !== oldVal) {\n        if (this.#hasFetchMethod && this.#isBackgroundFetch(oldVal)) {\n          oldVal.__abortController.abort(new Error('replaced'))\n          const { __staleWhileFetching: s } = oldVal\n          if (s !== undefined && !noDisposeOnSet) {\n            if (this.#hasDispose) {\n              this.#dispose?.(s as V, k, 'set')\n            }\n            if (this.#hasDisposeAfter) {\n              this.#disposed?.push([s as V, k, 'set'])\n            }\n          }\n        } else if (!noDisposeOnSet) {\n          if (this.#hasDispose) {\n            this.#dispose?.(oldVal as V, k, 'set')\n          }\n          if (this.#hasDisposeAfter) {\n            this.#disposed?.push([oldVal as V, k, 'set'])\n          }\n        }\n        this.#removeItemSize(index)\n        this.#addItemSize(index, size, status)\n        this.#valList[index] = v\n        if (status) {\n          status.set = 'replace'\n          const oldValue =\n            oldVal && this.#isBackgroundFetch(oldVal)\n              ? oldVal.__staleWhileFetching\n              : oldVal\n          if (oldValue !== undefined) status.oldValue = oldValue\n        }\n      } else if (status) {\n        status.set = 'update'\n      }\n    }\n    if (ttl !== 0 && !this.#ttls) {\n      this.#initializeTTLTracking()\n    }\n    if (this.#ttls) {\n      if (!noUpdateTTL) {\n        this.#setItemTTL(index, ttl, start)\n      }\n      if (status) this.#statusTTL(status, index)\n    }\n    if (!noDisposeOnSet && this.#hasDisposeAfter && this.#disposed) {\n      const dt = this.#disposed\n      let task: DisposeTask<K, V> | undefined\n      while ((task = dt?.shift())) {\n        this.#disposeAfter?.(...task)\n      }\n    }\n    return this\n  }\n\n  /**\n   * Evict the least recently used item, returning its value or\n   * `undefined` if cache is empty.\n   */\n  pop(): V | undefined {\n    try {\n      while (this.#size) {\n        const val = this.#valList[this.#head]\n        this.#evict(true)\n        if (this.#isBackgroundFetch(val)) {\n          if (val.__staleWhileFetching) {\n            return val.__staleWhileFetching\n          }\n        } else if (val !== undefined) {\n          return val\n        }\n      }\n    } finally {\n      if (this.#hasDisposeAfter && this.#disposed) {\n        const dt = this.#disposed\n        let task: DisposeTask<K, V> | undefined\n        while ((task = dt?.shift())) {\n          this.#disposeAfter?.(...task)\n        }\n      }\n    }\n  }\n\n  #evict(free: boolean) {\n    const head = this.#head\n    const k = this.#keyList[head] as K\n    const v = this.#valList[head] as V\n    if (this.#hasFetchMethod && this.#isBackgroundFetch(v)) {\n      v.__abortController.abort(new Error('evicted'))\n    } else if (this.#hasDispose || this.#hasDisposeAfter) {\n      if (this.#hasDispose) {\n        this.#dispose?.(v, k, 'evict')\n      }\n      if (this.#hasDisposeAfter) {\n        this.#disposed?.push([v, k, 'evict'])\n      }\n    }\n    this.#removeItemSize(head)\n    // if we aren't about to use the index, then null these out\n    if (free) {\n      this.#keyList[head] = undefined\n      this.#valList[head] = undefined\n      this.#free.push(head)\n    }\n    if (this.#size === 1) {\n      this.#head = this.#tail = 0 as Index\n      this.#free.length = 0\n    } else {\n      this.#head = this.#next[head] as Index\n    }\n    this.#keyMap.delete(k)\n    this.#size--\n    return head\n  }\n\n  /**\n   * Check if a key is in the cache, without updating the recency of use.\n   * Will return false if the item is stale, even though it is technically\n   * in the cache.\n   *\n   * Check if a key is in the cache, without updating the recency of\n   * use. Age is updated if {@link LRUCache.OptionsBase.updateAgeOnHas} is set\n   * to `true` in either the options or the constructor.\n   *\n   * Will return `false` if the item is stale, even though it is technically in\n   * the cache. The difference can be determined (if it matters) by using a\n   * `status` argument, and inspecting the `has` field.\n   *\n   * Will not update item age unless\n   * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.\n   */\n  has(k: K, hasOptions: LRUCache.HasOptions<K, V, FC> = {}) {\n    const { updateAgeOnHas = this.updateAgeOnHas, status } =\n      hasOptions\n    const index = this.#keyMap.get(k)\n    if (index !== undefined) {\n      const v = this.#valList[index]\n      if (\n        this.#isBackgroundFetch(v) &&\n        v.__staleWhileFetching === undefined\n      ) {\n        return false\n      }\n      if (!this.#isStale(index)) {\n        if (updateAgeOnHas) {\n          this.#updateItemAge(index)\n        }\n        if (status) {\n          status.has = 'hit'\n          this.#statusTTL(status, index)\n        }\n        return true\n      } else if (status) {\n        status.has = 'stale'\n        this.#statusTTL(status, index)\n      }\n    } else if (status) {\n      status.has = 'miss'\n    }\n    return false\n  }\n\n  /**\n   * Like {@link LRUCache#get} but doesn't update recency or delete stale\n   * items.\n   *\n   * Returns `undefined` if the item is stale, unless\n   * {@link LRUCache.OptionsBase.allowStale} is set.\n   */\n  peek(k: K, peekOptions: LRUCache.PeekOptions<K, V, FC> = {}) {\n    const { allowStale = this.allowStale } = peekOptions\n    const index = this.#keyMap.get(k)\n    if (\n      index === undefined ||\n      (!allowStale && this.#isStale(index))\n    ) {\n      return\n    }\n    const v = this.#valList[index]\n    // either stale and allowed, or forcing a refresh of non-stale value\n    return this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v\n  }\n\n  #backgroundFetch(\n    k: K,\n    index: Index | undefined,\n    options: LRUCache.FetchOptions<K, V, FC>,\n    context: any\n  ): BackgroundFetch<V> {\n    const v = index === undefined ? undefined : this.#valList[index]\n    if (this.#isBackgroundFetch(v)) {\n      return v\n    }\n\n    const ac = new AC()\n    const { signal } = options\n    // when/if our AC signals, then stop listening to theirs.\n    signal?.addEventListener('abort', () => ac.abort(signal.reason), {\n      signal: ac.signal,\n    })\n\n    const fetchOpts = {\n      signal: ac.signal,\n      options,\n      context,\n    }\n\n    const cb = (\n      v: V | undefined,\n      updateCache = false\n    ): V | undefined => {\n      const { aborted } = ac.signal\n      const ignoreAbort = options.ignoreFetchAbort && v !== undefined\n      if (options.status) {\n        if (aborted && !updateCache) {\n          options.status.fetchAborted = true\n          options.status.fetchError = ac.signal.reason\n          if (ignoreAbort) options.status.fetchAbortIgnored = true\n        } else {\n          options.status.fetchResolved = true\n        }\n      }\n      if (aborted && !ignoreAbort && !updateCache) {\n        return fetchFail(ac.signal.reason)\n      }\n      // either we didn't abort, and are still here, or we did, and ignored\n      const bf = p as BackgroundFetch<V>\n      if (this.#valList[index as Index] === p) {\n        if (v === undefined) {\n          if (bf.__staleWhileFetching) {\n            this.#valList[index as Index] = bf.__staleWhileFetching\n          } else {\n            this.#delete(k, 'fetch')\n          }\n        } else {\n          if (options.status) options.status.fetchUpdated = true\n          this.set(k, v, fetchOpts.options)\n        }\n      }\n      return v\n    }\n\n    const eb = (er: any) => {\n      if (options.status) {\n        options.status.fetchRejected = true\n        options.status.fetchError = er\n      }\n      return fetchFail(er)\n    }\n\n    const fetchFail = (er: any): V | undefined => {\n      const { aborted } = ac.signal\n      const allowStaleAborted =\n        aborted && options.allowStaleOnFetchAbort\n      const allowStale =\n        allowStaleAborted || options.allowStaleOnFetchRejection\n      const noDelete = allowStale || options.noDeleteOnFetchRejection\n      const bf = p as BackgroundFetch<V>\n      if (this.#valList[index as Index] === p) {\n        // if we allow stale on fetch rejections, then we need to ensure that\n        // the stale value is not removed from the cache when the fetch fails.\n        const del = !noDelete || bf.__staleWhileFetching === undefined\n        if (del) {\n          this.#delete(k, 'fetch')\n        } else if (!allowStaleAborted) {\n          // still replace the *promise* with the stale value,\n          // since we are done with the promise at this point.\n          // leave it untouched if we're still waiting for an\n          // aborted background fetch that hasn't yet returned.\n          this.#valList[index as Index] = bf.__staleWhileFetching\n        }\n      }\n      if (allowStale) {\n        if (options.status && bf.__staleWhileFetching !== undefined) {\n          options.status.returnedStale = true\n        }\n        return bf.__staleWhileFetching\n      } else if (bf.__returned === bf) {\n        throw er\n      }\n    }\n\n    const pcall = (\n      res: (v: V | undefined) => void,\n      rej: (e: any) => void\n    ) => {\n      const fmp = this.#fetchMethod?.(k, v, fetchOpts)\n      if (fmp && fmp instanceof Promise) {\n        fmp.then(v => res(v === undefined ? undefined : v), rej)\n      }\n      // ignored, we go until we finish, regardless.\n      // defer check until we are actually aborting,\n      // so fetchMethod can override.\n      ac.signal.addEventListener('abort', () => {\n        if (\n          !options.ignoreFetchAbort ||\n          options.allowStaleOnFetchAbort\n        ) {\n          res(undefined)\n          // when it eventually resolves, update the cache.\n          if (options.allowStaleOnFetchAbort) {\n            res = v => cb(v, true)\n          }\n        }\n      })\n    }\n\n    if (options.status) options.status.fetchDispatched = true\n    const p = new Promise(pcall).then(cb, eb)\n    const bf: BackgroundFetch<V> = Object.assign(p, {\n      __abortController: ac,\n      __staleWhileFetching: v,\n      __returned: undefined,\n    })\n\n    if (index === undefined) {\n      // internal, don't expose status.\n      this.set(k, bf, { ...fetchOpts.options, status: undefined })\n      index = this.#keyMap.get(k)\n    } else {\n      this.#valList[index] = bf\n    }\n    return bf\n  }\n\n  #isBackgroundFetch(p: any): p is BackgroundFetch<V> {\n    if (!this.#hasFetchMethod) return false\n    const b = p as BackgroundFetch<V>\n    return (\n      !!b &&\n      b instanceof Promise &&\n      b.hasOwnProperty('__staleWhileFetching') &&\n      b.__abortController instanceof AC\n    )\n  }\n\n  /**\n   * Make an asynchronous cached fetch using the\n   * {@link LRUCache.OptionsBase.fetchMethod} function.\n   *\n   * If the value is in the cache and not stale, then the returned\n   * Promise resolves to the value.\n   *\n   * If not in the cache, or beyond its TTL staleness, then\n   * `fetchMethod(key, staleValue, { options, signal, context })` is\n   * called, and the value returned will be added to the cache once\n   * resolved.\n   *\n   * If called with `allowStale`, and an asynchronous fetch is\n   * currently in progress to reload a stale value, then the former\n   * stale value will be returned.\n   *\n   * If called with `forceRefresh`, then the cached item will be\n   * re-fetched, even if it is not stale. However, if `allowStale` is also\n   * set, then the old value will still be returned. This is useful\n   * in cases where you want to force a reload of a cached value. If\n   * a background fetch is already in progress, then `forceRefresh`\n   * has no effect.\n   *\n   * If multiple fetches for the same key are issued, then they will all be\n   * coalesced into a single call to fetchMethod.\n   *\n   * Note that this means that handling options such as\n   * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort},\n   * {@link LRUCache.FetchOptions.signal},\n   * and {@link LRUCache.OptionsBase.allowStaleOnFetchRejection} will be\n   * determined by the FIRST fetch() call for a given key.\n   *\n   * This is a known (fixable) shortcoming which will be addresed on when\n   * someone complains about it, as the fix would involve added complexity and\n   * may not be worth the costs for this edge case.\n   *\n   * If {@link LRUCache.OptionsBase.fetchMethod} is not specified, then this is\n   * effectively an alias for `Promise.resolve(cache.get(key))`.\n   *\n   * When the fetch method resolves to a value, if the fetch has not\n   * been aborted due to deletion, eviction, or being overwritten,\n   * then it is added to the cache using the options provided.\n   *\n   * If the key is evicted or deleted before the `fetchMethod`\n   * resolves, then the AbortSignal passed to the `fetchMethod` will\n   * receive an `abort` event, and the promise returned by `fetch()`\n   * will reject with the reason for the abort.\n   *\n   * If a `signal` is passed to the `fetch()` call, then aborting the\n   * signal will abort the fetch and cause the `fetch()` promise to\n   * reject with the reason provided.\n   *\n   * **Setting `context`**\n   *\n   * If an `FC` type is set to a type other than `unknown`, `void`, or\n   * `undefined` in the {@link LRUCache} constructor, then all\n   * calls to `cache.fetch()` _must_ provide a `context` option. If\n   * set to `undefined` or `void`, then calls to fetch _must not_\n   * provide a `context` option.\n   *\n   * The `context` param allows you to provide arbitrary data that\n   * might be relevant in the course of fetching the data. It is only\n   * relevant for the course of a single `fetch()` operation, and\n   * discarded afterwards.\n   *\n   * **Note: `fetch()` calls are inflight-unique**\n   *\n   * If you call `fetch()` multiple times with the same key value,\n   * then every call after the first will resolve on the same\n   * promise<sup>1</sup>,\n   * _even if they have different settings that would otherwise change\n   * the behavior of the fetch_, such as `noDeleteOnFetchRejection`\n   * or `ignoreFetchAbort`.\n   *\n   * In most cases, this is not a problem (in fact, only fetching\n   * something once is what you probably want, if you're caching in\n   * the first place). If you are changing the fetch() options\n   * dramatically between runs, there's a good chance that you might\n   * be trying to fit divergent semantics into a single object, and\n   * would be better off with multiple cache instances.\n   *\n   * **1**: Ie, they're not the \"same Promise\", but they resolve at\n   * the same time, because they're both waiting on the same\n   * underlying fetchMethod response.\n   */\n\n  fetch(\n    k: K,\n    fetchOptions: unknown extends FC\n      ? LRUCache.FetchOptions<K, V, FC>\n      : FC extends undefined | void\n      ? LRUCache.FetchOptionsNoContext<K, V>\n      : LRUCache.FetchOptionsWithContext<K, V, FC>\n  ): Promise<undefined | V>\n\n  // this overload not allowed if context is required\n  fetch(\n    k: unknown extends FC\n      ? K\n      : FC extends undefined | void\n      ? K\n      : never,\n    fetchOptions?: unknown extends FC\n      ? LRUCache.FetchOptions<K, V, FC>\n      : FC extends undefined | void\n      ? LRUCache.FetchOptionsNoContext<K, V>\n      : never\n  ): Promise<undefined | V>\n\n  async fetch(\n    k: K,\n    fetchOptions: LRUCache.FetchOptions<K, V, FC> = {}\n  ): Promise<undefined | V> {\n    const {\n      // get options\n      allowStale = this.allowStale,\n      updateAgeOnGet = this.updateAgeOnGet,\n      noDeleteOnStaleGet = this.noDeleteOnStaleGet,\n      // set options\n      ttl = this.ttl,\n      noDisposeOnSet = this.noDisposeOnSet,\n      size = 0,\n      sizeCalculation = this.sizeCalculation,\n      noUpdateTTL = this.noUpdateTTL,\n      // fetch exclusive options\n      noDeleteOnFetchRejection = this.noDeleteOnFetchRejection,\n      allowStaleOnFetchRejection = this.allowStaleOnFetchRejection,\n      ignoreFetchAbort = this.ignoreFetchAbort,\n      allowStaleOnFetchAbort = this.allowStaleOnFetchAbort,\n      context,\n      forceRefresh = false,\n      status,\n      signal,\n    } = fetchOptions\n\n    if (!this.#hasFetchMethod) {\n      if (status) status.fetch = 'get'\n      return this.get(k, {\n        allowStale,\n        updateAgeOnGet,\n        noDeleteOnStaleGet,\n        status,\n      })\n    }\n\n    const options = {\n      allowStale,\n      updateAgeOnGet,\n      noDeleteOnStaleGet,\n      ttl,\n      noDisposeOnSet,\n      size,\n      sizeCalculation,\n      noUpdateTTL,\n      noDeleteOnFetchRejection,\n      allowStaleOnFetchRejection,\n      allowStaleOnFetchAbort,\n      ignoreFetchAbort,\n      status,\n      signal,\n    }\n\n    let index = this.#keyMap.get(k)\n    if (index === undefined) {\n      if (status) status.fetch = 'miss'\n      const p = this.#backgroundFetch(k, index, options, context)\n      return (p.__returned = p)\n    } else {\n      // in cache, maybe already fetching\n      const v = this.#valList[index]\n      if (this.#isBackgroundFetch(v)) {\n        const stale =\n          allowStale && v.__staleWhileFetching !== undefined\n        if (status) {\n          status.fetch = 'inflight'\n          if (stale) status.returnedStale = true\n        }\n        return stale ? v.__staleWhileFetching : (v.__returned = v)\n      }\n\n      // if we force a refresh, that means do NOT serve the cached value,\n      // unless we are already in the process of refreshing the cache.\n      const isStale = this.#isStale(index)\n      if (!forceRefresh && !isStale) {\n        if (status) status.fetch = 'hit'\n        this.#moveToTail(index)\n        if (updateAgeOnGet) {\n          this.#updateItemAge(index)\n        }\n        if (status) this.#statusTTL(status, index)\n        return v\n      }\n\n      // ok, it is stale or a forced refresh, and not already fetching.\n      // refresh the cache.\n      const p = this.#backgroundFetch(k, index, options, context)\n      const hasStale = p.__staleWhileFetching !== undefined\n      const staleVal = hasStale && allowStale\n      if (status) {\n        status.fetch = isStale ? 'stale' : 'refresh'\n        if (staleVal && isStale) status.returnedStale = true\n      }\n      return staleVal ? p.__staleWhileFetching : (p.__returned = p)\n    }\n  }\n\n  /**\n   * In some cases, `cache.fetch()` may resolve to `undefined`, either because\n   * a {@link LRUCache.OptionsBase#fetchMethod} was not provided (turning\n   * `cache.fetch(k)` into just an async wrapper around `cache.get(k)`) or\n   * because `ignoreFetchAbort` was specified (either to the constructor or\n   * in the {@link LRUCache.FetchOptions}). Also, the\n   * {@link OptionsBase.fetchMethod} may return `undefined` or `void`, making\n   * the test even more complicated.\n   *\n   * Because inferring the cases where `undefined` might be returned are so\n   * cumbersome, but testing for `undefined` can also be annoying, this method\n   * can be used, which will reject if `this.fetch()` resolves to undefined.\n   */\n  forceFetch(\n    k: K,\n    fetchOptions: unknown extends FC\n      ? LRUCache.FetchOptions<K, V, FC>\n      : FC extends undefined | void\n      ? LRUCache.FetchOptionsNoContext<K, V>\n      : LRUCache.FetchOptionsWithContext<K, V, FC>\n  ): Promise<V>\n  // this overload not allowed if context is required\n  forceFetch(\n    k: unknown extends FC\n      ? K\n      : FC extends undefined | void\n      ? K\n      : never,\n    fetchOptions?: unknown extends FC\n      ? LRUCache.FetchOptions<K, V, FC>\n      : FC extends undefined | void\n      ? LRUCache.FetchOptionsNoContext<K, V>\n      : never\n  ): Promise<V>\n  async forceFetch(\n    k: K,\n    fetchOptions: LRUCache.FetchOptions<K, V, FC> = {}\n  ): Promise<V> {\n    const v = await this.fetch(\n      k,\n      fetchOptions as unknown extends FC\n        ? LRUCache.FetchOptions<K, V, FC>\n        : FC extends undefined | void\n        ? LRUCache.FetchOptionsNoContext<K, V>\n        : LRUCache.FetchOptionsWithContext<K, V, FC>\n    )\n    if (v === undefined) throw new Error('fetch() returned undefined')\n    return v\n  }\n\n  /**\n   * If the key is found in the cache, then this is equivalent to\n   * {@link LRUCache#get}. If not, in the cache, then calculate the value using\n   * the {@link LRUCache.OptionsBase.memoMethod}, and add it to the cache.\n   *\n   * If an `FC` type is set to a type other than `unknown`, `void`, or\n   * `undefined` in the LRUCache constructor, then all calls to `cache.memo()`\n   * _must_ provide a `context` option. If set to `undefined` or `void`, then\n   * calls to memo _must not_ provide a `context` option.\n   *\n   * The `context` param allows you to provide arbitrary data that might be\n   * relevant in the course of fetching the data. It is only relevant for the\n   * course of a single `memo()` operation, and discarded afterwards.\n   */\n  memo(\n    k: K,\n    memoOptions: unknown extends FC\n      ? LRUCache.MemoOptions<K, V, FC>\n      : FC extends undefined | void\n      ? LRUCache.MemoOptionsNoContext<K, V>\n      : LRUCache.MemoOptionsWithContext<K, V, FC>\n  ): V\n  // this overload not allowed if context is required\n  memo(\n    k: unknown extends FC\n      ? K\n      : FC extends undefined | void\n      ? K\n      : never,\n    memoOptions?: unknown extends FC\n      ? LRUCache.MemoOptions<K, V, FC>\n      : FC extends undefined | void\n      ? LRUCache.MemoOptionsNoContext<K, V>\n      : never\n  ): V\n  memo(k: K, memoOptions: LRUCache.MemoOptions<K, V, FC> = {}) {\n    const memoMethod = this.#memoMethod\n    if (!memoMethod) {\n      throw new Error('no memoMethod provided to constructor')\n    }\n    const { context, forceRefresh, ...options } = memoOptions\n    const v = this.get(k, options)\n    if (!forceRefresh && v !== undefined) return v\n    const vv = memoMethod(k, v, {\n      options,\n      context,\n    } as LRUCache.MemoizerOptions<K, V, FC>)\n    this.set(k, vv, options)\n    return vv\n  }\n\n  /**\n   * Return a value from the cache. Will update the recency of the cache\n   * entry found.\n   *\n   * If the key is not found, get() will return `undefined`.\n   */\n  get(k: K, getOptions: LRUCache.GetOptions<K, V, FC> = {}) {\n    const {\n      allowStale = this.allowStale,\n      updateAgeOnGet = this.updateAgeOnGet,\n      noDeleteOnStaleGet = this.noDeleteOnStaleGet,\n      status,\n    } = getOptions\n    const index = this.#keyMap.get(k)\n    if (index !== undefined) {\n      const value = this.#valList[index]\n      const fetching = this.#isBackgroundFetch(value)\n      if (status) this.#statusTTL(status, index)\n      if (this.#isStale(index)) {\n        if (status) status.get = 'stale'\n        // delete only if not an in-flight background fetch\n        if (!fetching) {\n          if (!noDeleteOnStaleGet) {\n            this.#delete(k, 'expire')\n          }\n          if (status && allowStale) status.returnedStale = true\n          return allowStale ? value : undefined\n        } else {\n          if (\n            status &&\n            allowStale &&\n            value.__staleWhileFetching !== undefined\n          ) {\n            status.returnedStale = true\n          }\n          return allowStale ? value.__staleWhileFetching : undefined\n        }\n      } else {\n        if (status) status.get = 'hit'\n        // if we're currently fetching it, we don't actually have it yet\n        // it's not stale, which means this isn't a staleWhileRefetching.\n        // If it's not stale, and fetching, AND has a __staleWhileFetching\n        // value, then that means the user fetched with {forceRefresh:true},\n        // so it's safe to return that value.\n        if (fetching) {\n          return value.__staleWhileFetching\n        }\n        this.#moveToTail(index)\n        if (updateAgeOnGet) {\n          this.#updateItemAge(index)\n        }\n        return value\n      }\n    } else if (status) {\n      status.get = 'miss'\n    }\n  }\n\n  #connect(p: Index, n: Index) {\n    this.#prev[n] = p\n    this.#next[p] = n\n  }\n\n  #moveToTail(index: Index): void {\n    // if tail already, nothing to do\n    // if head, move head to next[index]\n    // else\n    //   move next[prev[index]] to next[index] (head has no prev)\n    //   move prev[next[index]] to prev[index]\n    // prev[index] = tail\n    // next[tail] = index\n    // tail = index\n    if (index !== this.#tail) {\n      if (index === this.#head) {\n        this.#head = this.#next[index] as Index\n      } else {\n        this.#connect(\n          this.#prev[index] as Index,\n          this.#next[index] as Index\n        )\n      }\n      this.#connect(this.#tail, index)\n      this.#tail = index\n    }\n  }\n\n  /**\n   * Deletes a key out of the cache.\n   *\n   * Returns true if the key was deleted, false otherwise.\n   */\n  delete(k: K) {\n    return this.#delete(k, 'delete')\n  }\n\n  #delete(k: K, reason: LRUCache.DisposeReason) {\n    let deleted = false\n    if (this.#size !== 0) {\n      const index = this.#keyMap.get(k)\n      if (index !== undefined) {\n        deleted = true\n        if (this.#size === 1) {\n          this.#clear(reason)\n        } else {\n          this.#removeItemSize(index)\n          const v = this.#valList[index]\n          if (this.#isBackgroundFetch(v)) {\n            v.__abortController.abort(new Error('deleted'))\n          } else if (this.#hasDispose || this.#hasDisposeAfter) {\n            if (this.#hasDispose) {\n              this.#dispose?.(v as V, k, reason)\n            }\n            if (this.#hasDisposeAfter) {\n              this.#disposed?.push([v as V, k, reason])\n            }\n          }\n          this.#keyMap.delete(k)\n          this.#keyList[index] = undefined\n          this.#valList[index] = undefined\n          if (index === this.#tail) {\n            this.#tail = this.#prev[index] as Index\n          } else if (index === this.#head) {\n            this.#head = this.#next[index] as Index\n          } else {\n            const pi = this.#prev[index] as number\n            this.#next[pi] = this.#next[index] as number\n            const ni = this.#next[index] as number\n            this.#prev[ni] = this.#prev[index] as number\n          }\n          this.#size--\n          this.#free.push(index)\n        }\n      }\n    }\n    if (this.#hasDisposeAfter && this.#disposed?.length) {\n      const dt = this.#disposed\n      let task: DisposeTask<K, V> | undefined\n      while ((task = dt?.shift())) {\n        this.#disposeAfter?.(...task)\n      }\n    }\n    return deleted\n  }\n\n  /**\n   * Clear the cache entirely, throwing away all values.\n   */\n  clear() {\n    return this.#clear('delete')\n  }\n  #clear(reason: LRUCache.DisposeReason) {\n    for (const index of this.#rindexes({ allowStale: true })) {\n      const v = this.#valList[index]\n      if (this.#isBackgroundFetch(v)) {\n        v.__abortController.abort(new Error('deleted'))\n      } else {\n        const k = this.#keyList[index]\n        if (this.#hasDispose) {\n          this.#dispose?.(v as V, k as K, reason)\n        }\n        if (this.#hasDisposeAfter) {\n          this.#disposed?.push([v as V, k as K, reason])\n        }\n      }\n    }\n\n    this.#keyMap.clear()\n    this.#valList.fill(undefined)\n    this.#keyList.fill(undefined)\n    if (this.#ttls && this.#starts) {\n      this.#ttls.fill(0)\n      this.#starts.fill(0)\n    }\n    if (this.#sizes) {\n      this.#sizes.fill(0)\n    }\n    this.#head = 0 as Index\n    this.#tail = 0 as Index\n    this.#free.length = 0\n    this.#calculatedSize = 0\n    this.#size = 0\n    if (this.#hasDisposeAfter && this.#disposed) {\n      const dt = this.#disposed\n      let task: DisposeTask<K, V> | undefined\n      while ((task = dt?.shift())) {\n        this.#disposeAfter?.(...task)\n      }\n    }\n  }\n}\n","import {\n  AppRouteRouteModule,\n  type AppRouteRouteHandlerContext,\n  type AppRouteRouteModuleOptions,\n} from '../../server/route-modules/app-route/module.compiled'\nimport { RouteKind } from '../../server/route-kind'\nimport { patchFetch as _patchFetch } from '../../server/lib/patch-fetch'\nimport type { IncomingMessage, ServerResponse } from 'node:http'\nimport { getRequestMeta } from '../../server/request-meta'\nimport { getTracer, type Span, SpanKind } from '../../server/lib/trace/tracer'\nimport { normalizeAppPath } from '../../shared/lib/router/utils/app-paths'\nimport { NodeNextRequest, NodeNextResponse } from '../../server/base-http/node'\nimport {\n  NextRequestAdapter,\n  signalFromNodeResponse,\n} from '../../server/web/spec-extension/adapters/next-request'\nimport { BaseServerSpan } from '../../server/lib/trace/constants'\nimport { getRevalidateReason } from '../../server/instrumentation/utils'\nimport { sendResponse } from '../../server/send-response'\nimport {\n  fromNodeOutgoingHttpHeaders,\n  toNodeOutgoingHttpHeaders,\n} from '../../server/web/utils'\nimport { getCacheControlHeader } from '../../server/lib/cache-control'\nimport { INFINITE_CACHE, NEXT_CACHE_TAGS_HEADER } from '../../lib/constants'\nimport { NoFallbackError } from '../../shared/lib/no-fallback-error.external'\nimport {\n  CachedRouteKind,\n  type ResponseCacheEntry,\n  type ResponseGenerator,\n} from '../../server/response-cache'\n\nimport * as userland from 'VAR_USERLAND'\n\n// These are injected by the loader afterwards. This is injected as a variable\n// instead of a replacement because this could also be `undefined` instead of\n// an empty string.\ndeclare const nextConfigOutput: AppRouteRouteModuleOptions['nextConfigOutput']\n\n// We inject the nextConfigOutput here so that we can use them in the route\n// module.\n// INJECT:nextConfigOutput\n\nconst routeModule = new AppRouteRouteModule({\n  definition: {\n    kind: RouteKind.APP_ROUTE,\n    page: 'VAR_DEFINITION_PAGE',\n    pathname: 'VAR_DEFINITION_PATHNAME',\n    filename: 'VAR_DEFINITION_FILENAME',\n    bundlePath: 'VAR_DEFINITION_BUNDLE_PATH',\n  },\n  distDir: process.env.__NEXT_RELATIVE_DIST_DIR || '',\n  relativeProjectDir: process.env.__NEXT_RELATIVE_PROJECT_DIR || '',\n  resolvedPagePath: 'VAR_RESOLVED_PAGE_PATH',\n  nextConfigOutput,\n  userland,\n})\n\n// Pull out the exports that we need to expose from the module. This should\n// be eliminated when we've moved the other routes to the new format. These\n// are used to hook into the route.\nconst { workAsyncStorage, workUnitAsyncStorage, serverHooks } = routeModule\n\nfunction patchFetch() {\n  return _patchFetch({\n    workAsyncStorage,\n    workUnitAsyncStorage,\n  })\n}\n\nexport {\n  routeModule,\n  workAsyncStorage,\n  workUnitAsyncStorage,\n  serverHooks,\n  patchFetch,\n}\n\nexport async function handler(\n  req: IncomingMessage,\n  res: ServerResponse,\n  ctx: {\n    waitUntil: (prom: Promise<void>) => void\n  }\n) {\n  let srcPage = 'VAR_DEFINITION_PAGE'\n\n  // turbopack doesn't normalize `/index` in the page name\n  // so we need to to process dynamic routes properly\n  // TODO: fix turbopack providing differing value from webpack\n  if (process.env.TURBOPACK) {\n    srcPage = srcPage.replace(/\\/index$/, '') || '/'\n  } else if (srcPage === '/index') {\n    // we always normalize /index specifically\n    srcPage = '/'\n  }\n  const multiZoneDraftMode = process.env\n    .__NEXT_MULTI_ZONE_DRAFT_MODE as any as boolean\n\n  const prepareResult = await routeModule.prepare(req, res, {\n    srcPage,\n    multiZoneDraftMode,\n  })\n\n  if (!prepareResult) {\n    res.statusCode = 400\n    res.end('Bad Request')\n    ctx.waitUntil?.(Promise.resolve())\n    return null\n  }\n\n  const {\n    buildId,\n    params,\n    nextConfig,\n    isDraftMode,\n    prerenderManifest,\n    routerServerContext,\n    isOnDemandRevalidate,\n    revalidateOnlyGenerated,\n    resolvedPathname,\n  } = prepareResult\n\n  const normalizedSrcPage = normalizeAppPath(srcPage)\n\n  let isIsr = Boolean(\n    prerenderManifest.dynamicRoutes[normalizedSrcPage] ||\n      prerenderManifest.routes[resolvedPathname]\n  )\n\n  if (isIsr && !isDraftMode) {\n    const isPrerendered = Boolean(prerenderManifest.routes[resolvedPathname])\n    const prerenderInfo = prerenderManifest.dynamicRoutes[normalizedSrcPage]\n\n    if (prerenderInfo) {\n      if (prerenderInfo.fallback === false && !isPrerendered) {\n        throw new NoFallbackError()\n      }\n    }\n  }\n\n  let cacheKey: string | null = null\n\n  if (isIsr && !routeModule.isDev && !isDraftMode) {\n    cacheKey = resolvedPathname\n    // ensure /index and / is normalized to one key\n    cacheKey = cacheKey === '/index' ? '/' : cacheKey\n  }\n\n  const supportsDynamicResponse: boolean =\n    // If we're in development, we always support dynamic HTML\n    routeModule.isDev === true ||\n    // If this is not SSG or does not have static paths, then it supports\n    // dynamic HTML.\n    !isIsr\n\n  // This is a revalidation request if the request is for a static\n  // page and it is not being resumed from a postponed render and\n  // it is not a dynamic RSC request then it is a revalidation\n  // request.\n  const isRevalidate = isIsr && !supportsDynamicResponse\n\n  const method = req.method || 'GET'\n  const tracer = getTracer()\n  const activeSpan = tracer.getActiveScopeSpan()\n\n  const context: AppRouteRouteHandlerContext = {\n    params,\n    prerenderManifest,\n    renderOpts: {\n      experimental: {\n        cacheComponents: Boolean(nextConfig.experimental.cacheComponents),\n        authInterrupts: Boolean(nextConfig.experimental.authInterrupts),\n      },\n      supportsDynamicResponse,\n      incrementalCache: getRequestMeta(req, 'incrementalCache'),\n      cacheLifeProfiles: nextConfig.experimental?.cacheLife,\n      isRevalidate,\n      waitUntil: ctx.waitUntil,\n      onClose: (cb) => {\n        res.on('close', cb)\n      },\n      onAfterTaskError: undefined,\n      onInstrumentationRequestError: (error, _request, errorContext) =>\n        routeModule.onRequestError(\n          req,\n          error,\n          errorContext,\n          routerServerContext\n        ),\n    },\n    sharedContext: {\n      buildId,\n    },\n  }\n  const nodeNextReq = new NodeNextRequest(req)\n  const nodeNextRes = new NodeNextResponse(res)\n\n  const nextReq = NextRequestAdapter.fromNodeNextRequest(\n    nodeNextReq,\n    signalFromNodeResponse(res)\n  )\n\n  try {\n    const invokeRouteModule = async (span?: Span) => {\n      return routeModule.handle(nextReq, context).finally(() => {\n        if (!span) return\n\n        span.setAttributes({\n          'http.status_code': res.statusCode,\n          'next.rsc': false,\n        })\n\n        const rootSpanAttributes = tracer.getRootSpanAttributes()\n        // We were unable to get attributes, probably OTEL is not enabled\n        if (!rootSpanAttributes) {\n          return\n        }\n\n        if (\n          rootSpanAttributes.get('next.span_type') !==\n          BaseServerSpan.handleRequest\n        ) {\n          console.warn(\n            `Unexpected root span type '${rootSpanAttributes.get(\n              'next.span_type'\n            )}'. Please report this Next.js issue https://github.com/vercel/next.js`\n          )\n          return\n        }\n\n        const route = rootSpanAttributes.get('next.route')\n        if (route) {\n          const name = `${method} ${route}`\n\n          span.setAttributes({\n            'next.route': route,\n            'http.route': route,\n            'next.span_name': name,\n          })\n          span.updateName(name)\n        } else {\n          span.updateName(`${method} ${req.url}`)\n        }\n      })\n    }\n\n    const handleResponse = async (currentSpan?: Span) => {\n      const responseGenerator: ResponseGenerator = async ({\n        previousCacheEntry,\n      }) => {\n        try {\n          if (\n            !getRequestMeta(req, 'minimalMode') &&\n            isOnDemandRevalidate &&\n            revalidateOnlyGenerated &&\n            !previousCacheEntry\n          ) {\n            res.statusCode = 404\n            // on-demand revalidate always sets this header\n            res.setHeader('x-nextjs-cache', 'REVALIDATED')\n            res.end('This page could not be found')\n            return null\n          }\n\n          const response = await invokeRouteModule(currentSpan)\n\n          ;(req as any).fetchMetrics = (context.renderOpts as any).fetchMetrics\n          let pendingWaitUntil = context.renderOpts.pendingWaitUntil\n\n          // Attempt using provided waitUntil if available\n          // if it's not we fallback to sendResponse's handling\n          if (pendingWaitUntil) {\n            if (ctx.waitUntil) {\n              ctx.waitUntil(pendingWaitUntil)\n              pendingWaitUntil = undefined\n            }\n          }\n          const cacheTags = context.renderOpts.collectedTags\n\n          // If the request is for a static response, we can cache it so long\n          // as it's not edge.\n          if (isIsr) {\n            const blob = await response.blob()\n\n            // Copy the headers from the response.\n            const headers = toNodeOutgoingHttpHeaders(response.headers)\n\n            if (cacheTags) {\n              headers[NEXT_CACHE_TAGS_HEADER] = cacheTags\n            }\n\n            if (!headers['content-type'] && blob.type) {\n              headers['content-type'] = blob.type\n            }\n\n            const revalidate =\n              typeof context.renderOpts.collectedRevalidate === 'undefined' ||\n              context.renderOpts.collectedRevalidate >= INFINITE_CACHE\n                ? false\n                : context.renderOpts.collectedRevalidate\n\n            const expire =\n              typeof context.renderOpts.collectedExpire === 'undefined' ||\n              context.renderOpts.collectedExpire >= INFINITE_CACHE\n                ? undefined\n                : context.renderOpts.collectedExpire\n\n            // Create the cache entry for the response.\n            const cacheEntry: ResponseCacheEntry = {\n              value: {\n                kind: CachedRouteKind.APP_ROUTE,\n                status: response.status,\n                body: Buffer.from(await blob.arrayBuffer()),\n                headers,\n              },\n              cacheControl: { revalidate, expire },\n            }\n\n            return cacheEntry\n          } else {\n            // send response without caching if not ISR\n            await sendResponse(\n              nodeNextReq,\n              nodeNextRes,\n              response,\n              context.renderOpts.pendingWaitUntil\n            )\n            return null\n          }\n        } catch (err) {\n          // if this is a background revalidate we need to report\n          // the request error here as it won't be bubbled\n          if (previousCacheEntry?.isStale) {\n            await routeModule.onRequestError(\n              req,\n              err,\n              {\n                routerKind: 'App Router',\n                routePath: srcPage,\n                routeType: 'route',\n                revalidateReason: getRevalidateReason({\n                  isRevalidate,\n                  isOnDemandRevalidate,\n                }),\n              },\n              routerServerContext\n            )\n          }\n          throw err\n        }\n      }\n\n      const cacheEntry = await routeModule.handleResponse({\n        req,\n        nextConfig,\n        cacheKey,\n        routeKind: RouteKind.APP_ROUTE,\n        isFallback: false,\n        prerenderManifest,\n        isRoutePPREnabled: false,\n        isOnDemandRevalidate,\n        revalidateOnlyGenerated,\n        responseGenerator,\n        waitUntil: ctx.waitUntil,\n      })\n\n      // we don't create a cacheEntry for ISR\n      if (!isIsr) {\n        return null\n      }\n\n      if (cacheEntry?.value?.kind !== CachedRouteKind.APP_ROUTE) {\n        throw new Error(\n          `Invariant: app-route received invalid cache entry ${cacheEntry?.value?.kind}`\n        )\n      }\n\n      if (!getRequestMeta(req, 'minimalMode')) {\n        res.setHeader(\n          'x-nextjs-cache',\n          isOnDemandRevalidate\n            ? 'REVALIDATED'\n            : cacheEntry.isMiss\n              ? 'MISS'\n              : cacheEntry.isStale\n                ? 'STALE'\n                : 'HIT'\n        )\n      }\n\n      // Draft mode should never be cached\n      if (isDraftMode) {\n        res.setHeader(\n          'Cache-Control',\n          'private, no-cache, no-store, max-age=0, must-revalidate'\n        )\n      }\n\n      const headers = fromNodeOutgoingHttpHeaders(cacheEntry.value.headers)\n\n      if (!(getRequestMeta(req, 'minimalMode') && isIsr)) {\n        headers.delete(NEXT_CACHE_TAGS_HEADER)\n      }\n\n      // If cache control is already set on the response we don't\n      // override it to allow users to customize it via next.config\n      if (\n        cacheEntry.cacheControl &&\n        !res.getHeader('Cache-Control') &&\n        !headers.get('Cache-Control')\n      ) {\n        headers.set(\n          'Cache-Control',\n          getCacheControlHeader(cacheEntry.cacheControl)\n        )\n      }\n\n      await sendResponse(\n        nodeNextReq,\n        nodeNextRes,\n        new Response(cacheEntry.value.body, {\n          headers,\n          status: cacheEntry.value.status || 200,\n        })\n      )\n      return null\n    }\n\n    // TODO: activeSpan code path is for when wrapped by\n    // next-server can be removed when this is no longer used\n    if (activeSpan) {\n      await handleResponse(activeSpan)\n    } else {\n      await tracer.withPropagatedContext(req.headers, () =>\n        tracer.trace(\n          BaseServerSpan.handleRequest,\n          {\n            spanName: `${method} ${req.url}`,\n            kind: SpanKind.SERVER,\n            attributes: {\n              'http.method': method,\n              'http.target': req.url,\n            },\n          },\n          handleResponse\n        )\n      )\n    }\n  } catch (err) {\n    // if we aren't wrapped by base-server handle here\n    if (!activeSpan && !(err instanceof NoFallbackError)) {\n      await routeModule.onRequestError(req, err, {\n        routerKind: 'App Router',\n        routePath: normalizedSrcPage,\n        routeType: 'route',\n        revalidateReason: getRevalidateReason({\n          isRevalidate,\n          isOnDemandRevalidate,\n        }),\n      })\n    }\n\n    // rethrow so that we can handle serving error page\n\n    // If this is during static generation, throw the error again.\n    if (isIsr) throw err\n\n    // Otherwise, send a 500 response.\n    await sendResponse(\n      nodeNextReq,\n      nodeNextRes,\n      new Response(null, { status: 500 })\n    )\n    return null\n  }\n}\n"],"names":["NextRequestAdapter","BaseServerSpan","NEXT_CACHE_TAGS_HEADER","workUnitAsyncStorage","serverHooks","patchFetch"],"mappings":"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","ignoreList":[1,3,4]}