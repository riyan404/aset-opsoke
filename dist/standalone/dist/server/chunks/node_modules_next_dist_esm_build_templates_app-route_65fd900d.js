module.exports=[79835,t=>{"use strict";t.s(["handler",()=>H,"patchFetch",()=>B,"routeModule",()=>N,"serverHooks",()=>W,"workAsyncStorage",()=>U,"workUnitAsyncStorage",()=>P],79835);var e=t.i(47909),i=t.i(74017),s=t.i(96250),r=t.i(59756),a=t.i(61916),h=t.i(69741),o=t.i(16795),l=t.i(87718),n=t.i(95169),d=t.i(47587),c=t.i(66012),u=t.i(70101),p=t.i(26937),f=t.i(10372),g=t.i(93695);t.i(52474);var v=t.i(220);t.s(["GET",()=>M],32963);var m=t.i(89171),S=t.i(24960),y=t.i(48886);let x="object"==typeof performance&&performance&&"function"==typeof performance.now?performance:Date,A=new Set,_="object"==typeof process&&process?process:{},z=(t,e,i,s)=>{"function"==typeof _.emitWarning?_.emitWarning(t,e,i,s):console.error(`[${i}] ${e}: ${t}`)},T=globalThis.AbortController,w=globalThis.AbortSignal;if(void 0===T){w=class{onabort;_onabort=[];reason;aborted=!1;addEventListener(t,e){this._onabort.push(e)}},T=class{constructor(){e()}signal=new w;abort(t){if(!this.signal.aborted){for(let e of(this.signal.reason=t,this.signal.aborted=!0,this.signal._onabort))e(t);this.signal.onabort?.(t)}}};let t=_.env?.LRU_CACHE_IGNORE_AC_WARNING!=="1",e=()=>{t&&(t=!1,z("AbortController is not defined. If using lru-cache in node 14, load an AbortController polyfill from the `node-abort-controller` package. A minimal polyfill is provided for use by LRUCache.fetch(), but it should not be relied upon in other contexts (eg, passing it to other APIs that use AbortController/AbortSignal might have undesirable effects). You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.","NO_ABORT_CONTROLLER","ENOTSUP",e))}}Symbol("type");let L=t=>t&&t===Math.floor(t)&&t>0&&isFinite(t),k=t=>L(t)?t<=256?Uint8Array:t<=65536?Uint16Array:t<=0x100000000?Uint32Array:t<=Number.MAX_SAFE_INTEGER?E:null:null;class E extends Array{constructor(t){super(t),this.fill(0)}}class F{heap;length;static #t=!1;static create(t){let e=k(t);if(!e)return[];F.#t=!0;let i=new F(t,e);return F.#t=!1,i}constructor(t,e){if(!F.#t)throw TypeError("instantiate Stack using Stack.create(n)");this.heap=new e(t),this.length=0}push(t){this.heap[this.length++]=t}pop(){return this.heap[--this.length]}}class b{#e;#i;#s;#r;#a;#h;ttl;ttlResolution;ttlAutopurge;updateAgeOnGet;updateAgeOnHas;allowStale;noDisposeOnSet;noUpdateTTL;maxEntrySize;sizeCalculation;noDeleteOnFetchRejection;noDeleteOnStaleGet;allowStaleOnFetchAbort;allowStaleOnFetchRejection;ignoreFetchAbort;#o;#l;#n;#d;#c;#u;#p;#f;#g;#v;#m;#S;#y;#x;#A;#_;#z;static unsafeExposeInternals(t){return{starts:t.#y,ttls:t.#x,sizes:t.#S,keyMap:t.#n,keyList:t.#d,valList:t.#c,next:t.#u,prev:t.#p,get head(){return t.#f},get tail(){return t.#g},free:t.#v,isBackgroundFetch:e=>t.#T(e),backgroundFetch:(e,i,s,r)=>t.#w(e,i,s,r),moveToTail:e=>t.#L(e),indexes:e=>t.#k(e),rindexes:e=>t.#E(e),isStale:e=>t.#F(e)}}get max(){return this.#e}get maxSize(){return this.#i}get calculatedSize(){return this.#l}get size(){return this.#o}get fetchMethod(){return this.#a}get memoMethod(){return this.#h}get dispose(){return this.#s}get disposeAfter(){return this.#r}constructor(t){let{max:e=0,ttl:i,ttlResolution:s=1,ttlAutopurge:r,updateAgeOnGet:a,updateAgeOnHas:h,allowStale:o,dispose:l,disposeAfter:n,noDisposeOnSet:d,noUpdateTTL:c,maxSize:u=0,maxEntrySize:p=0,sizeCalculation:f,fetchMethod:g,memoMethod:v,noDeleteOnFetchRejection:m,noDeleteOnStaleGet:S,allowStaleOnFetchRejection:y,allowStaleOnFetchAbort:x,ignoreFetchAbort:_}=t;if(0!==e&&!L(e))throw TypeError("max option must be a nonnegative integer");let T=e?k(e):Array;if(!T)throw Error("invalid max value: "+e);if(this.#e=e,this.#i=u,this.maxEntrySize=p||this.#i,this.sizeCalculation=f,this.sizeCalculation){if(!this.#i&&!this.maxEntrySize)throw TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");if("function"!=typeof this.sizeCalculation)throw TypeError("sizeCalculation set to non-function")}if(void 0!==v&&"function"!=typeof v)throw TypeError("memoMethod must be a function if defined");if(this.#h=v,void 0!==g&&"function"!=typeof g)throw TypeError("fetchMethod must be a function if specified");if(this.#a=g,this.#_=!!g,this.#n=new Map,this.#d=Array(e).fill(void 0),this.#c=Array(e).fill(void 0),this.#u=new T(e),this.#p=new T(e),this.#f=0,this.#g=0,this.#v=F.create(e),this.#o=0,this.#l=0,"function"==typeof l&&(this.#s=l),"function"==typeof n?(this.#r=n,this.#m=[]):(this.#r=void 0,this.#m=void 0),this.#A=!!this.#s,this.#z=!!this.#r,this.noDisposeOnSet=!!d,this.noUpdateTTL=!!c,this.noDeleteOnFetchRejection=!!m,this.allowStaleOnFetchRejection=!!y,this.allowStaleOnFetchAbort=!!x,this.ignoreFetchAbort=!!_,0!==this.maxEntrySize){if(0!==this.#i&&!L(this.#i))throw TypeError("maxSize must be a positive integer if specified");if(!L(this.maxEntrySize))throw TypeError("maxEntrySize must be a positive integer if specified");this.#b()}if(this.allowStale=!!o,this.noDeleteOnStaleGet=!!S,this.updateAgeOnGet=!!a,this.updateAgeOnHas=!!h,this.ttlResolution=L(s)||0===s?s:1,this.ttlAutopurge=!!r,this.ttl=i||0,this.ttl){if(!L(this.ttl))throw TypeError("ttl must be a positive integer if specified");this.#R()}if(0===this.#e&&0===this.ttl&&0===this.#i)throw TypeError("At least one of max, maxSize, or ttl is required");if(!this.ttlAutopurge&&!this.#e&&!this.#i){let t="LRU_CACHE_UNBOUNDED";A.has(t)||(A.add(t),z("TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.","UnboundedCacheWarning",t,b))}}getRemainingTTL(t){return this.#n.has(t)?1/0:0}#R(){let t=new E(this.#e),e=new E(this.#e);this.#x=t,this.#y=e,this.#C=(i,s,r=x.now())=>{if(e[i]=0!==s?r:0,t[i]=s,0!==s&&this.ttlAutopurge){let t=setTimeout(()=>{this.#F(i)&&this.#O(this.#d[i],"expire")},s+1);t.unref&&t.unref()}},this.#D=i=>{e[i]=0!==t[i]?x.now():0},this.#M=(r,a)=>{if(t[a]){let h=t[a],o=e[a];if(!h||!o)return;r.ttl=h,r.start=o,r.now=i||s();let l=r.now-o;r.remainingTTL=h-l}};let i=0,s=()=>{let t=x.now();if(this.ttlResolution>0){i=t;let e=setTimeout(()=>i=0,this.ttlResolution);e.unref&&e.unref()}return t};this.getRemainingTTL=r=>{let a=this.#n.get(r);if(void 0===a)return 0;let h=t[a],o=e[a];return h&&o?h-((i||s())-o):1/0},this.#F=r=>{let a=e[r],h=t[r];return!!h&&!!a&&(i||s())-a>h}}#D=()=>{};#M=()=>{};#C=()=>{};#F=()=>!1;#b(){let t=new E(this.#e);this.#l=0,this.#S=t,this.#I=e=>{this.#l-=t[e],t[e]=0},this.#N=(t,e,i,s)=>{if(this.#T(e))return 0;if(!L(i))if(s){if("function"!=typeof s)throw TypeError("sizeCalculation must be a function");if(!L(i=s(e,t)))throw TypeError("sizeCalculation return invalid (expect positive integer)")}else throw TypeError("invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.");return i},this.#U=(e,i,s)=>{if(t[e]=i,this.#i){let i=this.#i-t[e];for(;this.#l>i;)this.#P(!0)}this.#l+=t[e],s&&(s.entrySize=i,s.totalCalculatedSize=this.#l)}}#I=t=>{};#U=(t,e,i)=>{};#N=(t,e,i,s)=>{if(i||s)throw TypeError("cannot set size without setting maxSize or maxEntrySize on cache");return 0};*#k({allowStale:t=this.allowStale}={}){if(this.#o)for(let e=this.#g;this.#W(e)&&((t||!this.#F(e))&&(yield e),e!==this.#f);)e=this.#p[e]}*#E({allowStale:t=this.allowStale}={}){if(this.#o)for(let e=this.#f;this.#W(e)&&((t||!this.#F(e))&&(yield e),e!==this.#g);)e=this.#u[e]}#W(t){return void 0!==t&&this.#n.get(this.#d[t])===t}*entries(){for(let t of this.#k())void 0===this.#c[t]||void 0===this.#d[t]||this.#T(this.#c[t])||(yield[this.#d[t],this.#c[t]])}*rentries(){for(let t of this.#E())void 0===this.#c[t]||void 0===this.#d[t]||this.#T(this.#c[t])||(yield[this.#d[t],this.#c[t]])}*keys(){for(let t of this.#k()){let e=this.#d[t];void 0===e||this.#T(this.#c[t])||(yield e)}}*rkeys(){for(let t of this.#E()){let e=this.#d[t];void 0===e||this.#T(this.#c[t])||(yield e)}}*values(){for(let t of this.#k())void 0===this.#c[t]||this.#T(this.#c[t])||(yield this.#c[t])}*rvalues(){for(let t of this.#E())void 0===this.#c[t]||this.#T(this.#c[t])||(yield this.#c[t])}[Symbol.iterator](){return this.entries()}[Symbol.toStringTag]="LRUCache";find(t,e={}){for(let i of this.#k()){let s=this.#c[i],r=this.#T(s)?s.__staleWhileFetching:s;if(void 0!==r&&t(r,this.#d[i],this))return this.get(this.#d[i],e)}}forEach(t,e=this){for(let i of this.#k()){let s=this.#c[i],r=this.#T(s)?s.__staleWhileFetching:s;void 0!==r&&t.call(e,r,this.#d[i],this)}}rforEach(t,e=this){for(let i of this.#E()){let s=this.#c[i],r=this.#T(s)?s.__staleWhileFetching:s;void 0!==r&&t.call(e,r,this.#d[i],this)}}purgeStale(){let t=!1;for(let e of this.#E({allowStale:!0}))this.#F(e)&&(this.#O(this.#d[e],"expire"),t=!0);return t}info(t){let e=this.#n.get(t);if(void 0===e)return;let i=this.#c[e],s=this.#T(i)?i.__staleWhileFetching:i;if(void 0===s)return;let r={value:s};if(this.#x&&this.#y){let t=this.#x[e],i=this.#y[e];t&&i&&(r.ttl=t-(x.now()-i),r.start=Date.now())}return this.#S&&(r.size=this.#S[e]),r}dump(){let t=[];for(let e of this.#k({allowStale:!0})){let i=this.#d[e],s=this.#c[e],r=this.#T(s)?s.__staleWhileFetching:s;if(void 0===r||void 0===i)continue;let a={value:r};if(this.#x&&this.#y){a.ttl=this.#x[e];let t=x.now()-this.#y[e];a.start=Math.floor(Date.now()-t)}this.#S&&(a.size=this.#S[e]),t.unshift([i,a])}return t}load(t){for(let[e,i]of(this.clear(),t)){if(i.start){let t=Date.now()-i.start;i.start=x.now()-t}this.set(e,i.value,i)}}set(t,e,i={}){if(void 0===e)return this.delete(t),this;let{ttl:s=this.ttl,start:r,noDisposeOnSet:a=this.noDisposeOnSet,sizeCalculation:h=this.sizeCalculation,status:o}=i,{noUpdateTTL:l=this.noUpdateTTL}=i,n=this.#N(t,e,i.size||0,h);if(this.maxEntrySize&&n>this.maxEntrySize)return o&&(o.set="miss",o.maxEntrySizeExceeded=!0),this.#O(t,"set"),this;let d=0===this.#o?void 0:this.#n.get(t);if(void 0===d)d=0===this.#o?this.#g:0!==this.#v.length?this.#v.pop():this.#o===this.#e?this.#P(!1):this.#o,this.#d[d]=t,this.#c[d]=e,this.#n.set(t,d),this.#u[this.#g]=d,this.#p[d]=this.#g,this.#g=d,this.#o++,this.#U(d,n,o),o&&(o.set="add"),l=!1;else{this.#L(d);let i=this.#c[d];if(e!==i){if(this.#_&&this.#T(i)){i.__abortController.abort(Error("replaced"));let{__staleWhileFetching:e}=i;void 0!==e&&!a&&(this.#A&&this.#s?.(e,t,"set"),this.#z&&this.#m?.push([e,t,"set"]))}else!a&&(this.#A&&this.#s?.(i,t,"set"),this.#z&&this.#m?.push([i,t,"set"]));if(this.#I(d),this.#U(d,n,o),this.#c[d]=e,o){o.set="replace";let t=i&&this.#T(i)?i.__staleWhileFetching:i;void 0!==t&&(o.oldValue=t)}}else o&&(o.set="update")}if(0===s||this.#x||this.#R(),this.#x&&(l||this.#C(d,s,r),o&&this.#M(o,d)),!a&&this.#z&&this.#m){let t,e=this.#m;for(;t=e?.shift();)this.#r?.(...t)}return this}pop(){try{for(;this.#o;){let t=this.#c[this.#f];if(this.#P(!0),this.#T(t)){if(t.__staleWhileFetching)return t.__staleWhileFetching}else if(void 0!==t)return t}}finally{if(this.#z&&this.#m){let t,e=this.#m;for(;t=e?.shift();)this.#r?.(...t)}}}#P(t){let e=this.#f,i=this.#d[e],s=this.#c[e];return this.#_&&this.#T(s)?s.__abortController.abort(Error("evicted")):(this.#A||this.#z)&&(this.#A&&this.#s?.(s,i,"evict"),this.#z&&this.#m?.push([s,i,"evict"])),this.#I(e),t&&(this.#d[e]=void 0,this.#c[e]=void 0,this.#v.push(e)),1===this.#o?(this.#f=this.#g=0,this.#v.length=0):this.#f=this.#u[e],this.#n.delete(i),this.#o--,e}has(t,e={}){let{updateAgeOnHas:i=this.updateAgeOnHas,status:s}=e,r=this.#n.get(t);if(void 0!==r){let t=this.#c[r];if(this.#T(t)&&void 0===t.__staleWhileFetching)return!1;if(!this.#F(r))return i&&this.#D(r),s&&(s.has="hit",this.#M(s,r)),!0;s&&(s.has="stale",this.#M(s,r))}else s&&(s.has="miss");return!1}peek(t,e={}){let{allowStale:i=this.allowStale}=e,s=this.#n.get(t);if(void 0===s||!i&&this.#F(s))return;let r=this.#c[s];return this.#T(r)?r.__staleWhileFetching:r}#w(t,e,i,s){let r=void 0===e?void 0:this.#c[e];if(this.#T(r))return r;let a=new T,{signal:h}=i;h?.addEventListener("abort",()=>a.abort(h.reason),{signal:a.signal});let o={signal:a.signal,options:i,context:s},l=(s,r=!1)=>{let{aborted:h}=a.signal,l=i.ignoreFetchAbort&&void 0!==s;return(i.status&&(h&&!r?(i.status.fetchAborted=!0,i.status.fetchError=a.signal.reason,l&&(i.status.fetchAbortIgnored=!0)):i.status.fetchResolved=!0),!h||l||r)?(this.#c[e]===c&&(void 0===s?c.__staleWhileFetching?this.#c[e]=c.__staleWhileFetching:this.#O(t,"fetch"):(i.status&&(i.status.fetchUpdated=!0),this.set(t,s,o.options))),s):n(a.signal.reason)},n=s=>{let{aborted:r}=a.signal,h=r&&i.allowStaleOnFetchAbort,o=h||i.allowStaleOnFetchRejection,l=o||i.noDeleteOnFetchRejection;if(this.#c[e]===c&&(l&&void 0!==c.__staleWhileFetching?h||(this.#c[e]=c.__staleWhileFetching):this.#O(t,"fetch")),o)return i.status&&void 0!==c.__staleWhileFetching&&(i.status.returnedStale=!0),c.__staleWhileFetching;if(c.__returned===c)throw s},d=(e,s)=>{let h=this.#a?.(t,r,o);h&&h instanceof Promise&&h.then(t=>e(void 0===t?void 0:t),s),a.signal.addEventListener("abort",()=>{(!i.ignoreFetchAbort||i.allowStaleOnFetchAbort)&&(e(void 0),i.allowStaleOnFetchAbort&&(e=t=>l(t,!0)))})};i.status&&(i.status.fetchDispatched=!0);let c=new Promise(d).then(l,t=>(i.status&&(i.status.fetchRejected=!0,i.status.fetchError=t),n(t))),u=Object.assign(c,{__abortController:a,__staleWhileFetching:r,__returned:void 0});return void 0===e?(this.set(t,u,{...o.options,status:void 0}),e=this.#n.get(t)):this.#c[e]=u,u}#T(t){return!!this.#_&&!!t&&t instanceof Promise&&t.hasOwnProperty("__staleWhileFetching")&&t.__abortController instanceof T}async fetch(t,e={}){let{allowStale:i=this.allowStale,updateAgeOnGet:s=this.updateAgeOnGet,noDeleteOnStaleGet:r=this.noDeleteOnStaleGet,ttl:a=this.ttl,noDisposeOnSet:h=this.noDisposeOnSet,size:o=0,sizeCalculation:l=this.sizeCalculation,noUpdateTTL:n=this.noUpdateTTL,noDeleteOnFetchRejection:d=this.noDeleteOnFetchRejection,allowStaleOnFetchRejection:c=this.allowStaleOnFetchRejection,ignoreFetchAbort:u=this.ignoreFetchAbort,allowStaleOnFetchAbort:p=this.allowStaleOnFetchAbort,context:f,forceRefresh:g=!1,status:v,signal:m}=e;if(!this.#_)return v&&(v.fetch="get"),this.get(t,{allowStale:i,updateAgeOnGet:s,noDeleteOnStaleGet:r,status:v});let S={allowStale:i,updateAgeOnGet:s,noDeleteOnStaleGet:r,ttl:a,noDisposeOnSet:h,size:o,sizeCalculation:l,noUpdateTTL:n,noDeleteOnFetchRejection:d,allowStaleOnFetchRejection:c,allowStaleOnFetchAbort:p,ignoreFetchAbort:u,status:v,signal:m},y=this.#n.get(t);if(void 0===y){v&&(v.fetch="miss");let e=this.#w(t,y,S,f);return e.__returned=e}{let e=this.#c[y];if(this.#T(e)){let t=i&&void 0!==e.__staleWhileFetching;return v&&(v.fetch="inflight",t&&(v.returnedStale=!0)),t?e.__staleWhileFetching:e.__returned=e}let r=this.#F(y);if(!g&&!r)return v&&(v.fetch="hit"),this.#L(y),s&&this.#D(y),v&&this.#M(v,y),e;let a=this.#w(t,y,S,f),h=void 0!==a.__staleWhileFetching&&i;return v&&(v.fetch=r?"stale":"refresh",h&&r&&(v.returnedStale=!0)),h?a.__staleWhileFetching:a.__returned=a}}async forceFetch(t,e={}){let i=await this.fetch(t,e);if(void 0===i)throw Error("fetch() returned undefined");return i}memo(t,e={}){let i=this.#h;if(!i)throw Error("no memoMethod provided to constructor");let{context:s,forceRefresh:r,...a}=e,h=this.get(t,a);if(!r&&void 0!==h)return h;let o=i(t,h,{options:a,context:s});return this.set(t,o,a),o}get(t,e={}){let{allowStale:i=this.allowStale,updateAgeOnGet:s=this.updateAgeOnGet,noDeleteOnStaleGet:r=this.noDeleteOnStaleGet,status:a}=e,h=this.#n.get(t);if(void 0!==h){let e=this.#c[h],o=this.#T(e);return(a&&this.#M(a,h),this.#F(h))?(a&&(a.get="stale"),o)?(a&&i&&void 0!==e.__staleWhileFetching&&(a.returnedStale=!0),i?e.__staleWhileFetching:void 0):(r||this.#O(t,"expire"),a&&i&&(a.returnedStale=!0),i?e:void 0):(a&&(a.get="hit"),o)?e.__staleWhileFetching:(this.#L(h),s&&this.#D(h),e)}a&&(a.get="miss")}#B(t,e){this.#p[e]=t,this.#u[t]=e}#L(t){t!==this.#g&&(t===this.#f?this.#f=this.#u[t]:this.#B(this.#p[t],this.#u[t]),this.#B(this.#g,t),this.#g=t)}delete(t){return this.#O(t,"delete")}#O(t,e){let i=!1;if(0!==this.#o){let s=this.#n.get(t);if(void 0!==s)if(i=!0,1===this.#o)this.#H(e);else{this.#I(s);let i=this.#c[s];if(this.#T(i)?i.__abortController.abort(Error("deleted")):(this.#A||this.#z)&&(this.#A&&this.#s?.(i,t,e),this.#z&&this.#m?.push([i,t,e])),this.#n.delete(t),this.#d[s]=void 0,this.#c[s]=void 0,s===this.#g)this.#g=this.#p[s];else if(s===this.#f)this.#f=this.#u[s];else{let t=this.#p[s];this.#u[t]=this.#u[s];let e=this.#u[s];this.#p[e]=this.#p[s]}this.#o--,this.#v.push(s)}}if(this.#z&&this.#m?.length){let t,e=this.#m;for(;t=e?.shift();)this.#r?.(...t)}return i}clear(){return this.#H("delete")}#H(t){for(let e of this.#E({allowStale:!0})){let i=this.#c[e];if(this.#T(i))i.__abortController.abort(Error("deleted"));else{let s=this.#d[e];this.#A&&this.#s?.(i,s,t),this.#z&&this.#m?.push([i,s,t])}}if(this.#n.clear(),this.#c.fill(void 0),this.#d.fill(void 0),this.#x&&this.#y&&(this.#x.fill(0),this.#y.fill(0)),this.#S&&this.#S.fill(0),this.#f=0,this.#g=0,this.#v.length=0,this.#l=0,this.#o=0,this.#z&&this.#m){let t,e=this.#m;for(;t=e?.shift();)this.#r?.(...t)}}}let R=new b({max:500,ttl:18e4}),C=new b({max:200,ttl:3e5}),O=new b({max:50,ttl:6e4});class D{static getPermissions(t){return R.get(t)}static setPermissions(t,e){R.set(t,e)}static clearPermissions(t){t?R.delete(t):R.clear()}static getUser(t){return C.get(t)}static setUser(t,e){C.set(t,e)}static clearUser(t){t?C.delete(t):C.clear()}static getDigitalAssets(t){return O.get(t)}static setDigitalAssets(t,e){O.set(t,e)}static clearDigitalAssets(t){t?O.delete(t):O.clear()}static clearAll(){R.clear(),C.clear(),O.clear()}static performCleanup(){R.purgeStale(),C.purgeStale(),O.purgeStale()}static getCacheStats(){return{permissions:{size:R.size,max:R.max,ttl:18e4},users:{size:C.size,max:C.max,ttl:3e5},digitalAssets:{size:O.size,max:O.max,ttl:6e4}}}static generatePermissionKey(t,e,i){return`perm:${t||"null"}:${e}:${i}`}static generateUserKey(t){return`user:${t}`}static generateDigitalAssetsKey(t){let{page:e,limit:i,search:s="",aspectRatio:r="",department:a=""}=t;return`digital-assets:${e}:${i}:${s}:${r}:${a}`}}let M=(0,S.withAuth)(async t=>{try{let e=t.user,i=D.generatePermissionKey(e.department,e.role,"DIGITAL_ASSETS"),s=D.getPermissions(i);if(s)return m.NextResponse.json(s);let r=await (0,y.checkUserPermissions)(e.department,e.role,y.SYSTEM_MODULES.DIGITAL_ASSETS);return m.NextResponse.json(r)}catch(t){return console.error("Error checking permissions:",t),m.NextResponse.json({error:"Internal server error"},{status:500})}});var I=t.i(32963);let N=new e.AppRouteRouteModule({definition:{kind:i.RouteKind.APP_ROUTE,page:"/api/permissions/digital-assets/route",pathname:"/api/permissions/digital-assets",filename:"route",bundlePath:""},distDir:"dist",relativeProjectDir:"",resolvedPagePath:"[project]/src/app/api/permissions/digital-assets/route.ts",nextConfigOutput:"standalone",userland:I}),{workAsyncStorage:U,workUnitAsyncStorage:P,serverHooks:W}=N;function B(){return(0,s.patchFetch)({workAsyncStorage:U,workUnitAsyncStorage:P})}async function H(t,e,s){var m;let S="/api/permissions/digital-assets/route";S=S.replace(/\/index$/,"")||"/";let y=await N.prepare(t,e,{srcPage:S,multiZoneDraftMode:!1});if(!y)return e.statusCode=400,e.end("Bad Request"),null==s.waitUntil||s.waitUntil.call(s,Promise.resolve()),null;let{buildId:x,params:A,nextConfig:_,isDraftMode:z,prerenderManifest:T,routerServerContext:w,isOnDemandRevalidate:L,revalidateOnlyGenerated:k,resolvedPathname:E}=y,F=(0,h.normalizeAppPath)(S),b=!!(T.dynamicRoutes[F]||T.routes[E]);if(b&&!z){let t=!!T.routes[E],e=T.dynamicRoutes[F];if(e&&!1===e.fallback&&!t)throw new g.NoFallbackError}let R=null;!b||N.isDev||z||(R="/index"===(R=E)?"/":R);let C=!0===N.isDev||!b,O=b&&!C,D=t.method||"GET",M=(0,a.getTracer)(),I=M.getActiveScopeSpan(),U={params:A,prerenderManifest:T,renderOpts:{experimental:{cacheComponents:!!_.experimental.cacheComponents,authInterrupts:!!_.experimental.authInterrupts},supportsDynamicResponse:C,incrementalCache:(0,r.getRequestMeta)(t,"incrementalCache"),cacheLifeProfiles:null==(m=_.experimental)?void 0:m.cacheLife,isRevalidate:O,waitUntil:s.waitUntil,onClose:t=>{e.on("close",t)},onAfterTaskError:void 0,onInstrumentationRequestError:(e,i,s)=>N.onRequestError(t,e,s,w)},sharedContext:{buildId:x}},P=new o.NodeNextRequest(t),W=new o.NodeNextResponse(e),B=l.NextRequestAdapter.fromNodeNextRequest(P,(0,l.signalFromNodeResponse)(e));try{let h=async i=>N.handle(B,U).finally(()=>{if(!i)return;i.setAttributes({"http.status_code":e.statusCode,"next.rsc":!1});let s=M.getRootSpanAttributes();if(!s)return;if(s.get("next.span_type")!==n.BaseServerSpan.handleRequest)return void console.warn(`Unexpected root span type '${s.get("next.span_type")}'. Please report this Next.js issue https://github.com/vercel/next.js`);let r=s.get("next.route");if(r){let t=`${D} ${r}`;i.setAttributes({"next.route":r,"http.route":r,"next.span_name":t}),i.updateName(t)}else i.updateName(`${D} ${t.url}`)}),o=async a=>{var o,l;let n=async({previousCacheEntry:i})=>{try{if(!(0,r.getRequestMeta)(t,"minimalMode")&&L&&k&&!i)return e.statusCode=404,e.setHeader("x-nextjs-cache","REVALIDATED"),e.end("This page could not be found"),null;let o=await h(a);t.fetchMetrics=U.renderOpts.fetchMetrics;let l=U.renderOpts.pendingWaitUntil;l&&s.waitUntil&&(s.waitUntil(l),l=void 0);let n=U.renderOpts.collectedTags;if(!b)return await (0,c.sendResponse)(P,W,o,U.renderOpts.pendingWaitUntil),null;{let t=await o.blob(),e=(0,u.toNodeOutgoingHttpHeaders)(o.headers);n&&(e[f.NEXT_CACHE_TAGS_HEADER]=n),!e["content-type"]&&t.type&&(e["content-type"]=t.type);let i=void 0!==U.renderOpts.collectedRevalidate&&!(U.renderOpts.collectedRevalidate>=f.INFINITE_CACHE)&&U.renderOpts.collectedRevalidate,s=void 0===U.renderOpts.collectedExpire||U.renderOpts.collectedExpire>=f.INFINITE_CACHE?void 0:U.renderOpts.collectedExpire;return{value:{kind:v.CachedRouteKind.APP_ROUTE,status:o.status,body:Buffer.from(await t.arrayBuffer()),headers:e},cacheControl:{revalidate:i,expire:s}}}}catch(e){throw(null==i?void 0:i.isStale)&&await N.onRequestError(t,e,{routerKind:"App Router",routePath:S,routeType:"route",revalidateReason:(0,d.getRevalidateReason)({isRevalidate:O,isOnDemandRevalidate:L})},w),e}},g=await N.handleResponse({req:t,nextConfig:_,cacheKey:R,routeKind:i.RouteKind.APP_ROUTE,isFallback:!1,prerenderManifest:T,isRoutePPREnabled:!1,isOnDemandRevalidate:L,revalidateOnlyGenerated:k,responseGenerator:n,waitUntil:s.waitUntil});if(!b)return null;if((null==g||null==(o=g.value)?void 0:o.kind)!==v.CachedRouteKind.APP_ROUTE)throw Object.defineProperty(Error(`Invariant: app-route received invalid cache entry ${null==g||null==(l=g.value)?void 0:l.kind}`),"__NEXT_ERROR_CODE",{value:"E701",enumerable:!1,configurable:!0});(0,r.getRequestMeta)(t,"minimalMode")||e.setHeader("x-nextjs-cache",L?"REVALIDATED":g.isMiss?"MISS":g.isStale?"STALE":"HIT"),z&&e.setHeader("Cache-Control","private, no-cache, no-store, max-age=0, must-revalidate");let m=(0,u.fromNodeOutgoingHttpHeaders)(g.value.headers);return(0,r.getRequestMeta)(t,"minimalMode")&&b||m.delete(f.NEXT_CACHE_TAGS_HEADER),!g.cacheControl||e.getHeader("Cache-Control")||m.get("Cache-Control")||m.set("Cache-Control",(0,p.getCacheControlHeader)(g.cacheControl)),await (0,c.sendResponse)(P,W,new Response(g.value.body,{headers:m,status:g.value.status||200})),null};I?await o(I):await M.withPropagatedContext(t.headers,()=>M.trace(n.BaseServerSpan.handleRequest,{spanName:`${D} ${t.url}`,kind:a.SpanKind.SERVER,attributes:{"http.method":D,"http.target":t.url}},o))}catch(e){if(I||e instanceof g.NoFallbackError||await N.onRequestError(t,e,{routerKind:"App Router",routePath:F,routeType:"route",revalidateReason:(0,d.getRevalidateReason)({isRevalidate:O,isOnDemandRevalidate:L})}),b)throw e;return await (0,c.sendResponse)(P,W,new Response(null,{status:500})),null}}}];

//# sourceMappingURL=node_modules_next_dist_esm_build_templates_app-route_65fd900d.js.map